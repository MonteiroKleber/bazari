// path: apps/api/prisma/schema.prisma

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
  extensions        = [pg_trgm]
}

model MediaAsset {
  id          String   @id @default(cuid())
  url         String // FS: /uploads/abc.png; S3: URL pública
  mime        String
  size        Int
  contentHash String
  ownerType   String?
  ownerId     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([ownerType, ownerId])
  @@index([contentHash])
}

model Category {
  id          String   @id
  slug        String   @unique
  parentId    String?
  kind        String // "product" | "service"
  level       Int // 1..4
  namePt      String
  nameEn      String
  nameEs      String
  pathSlugs   String[]
  pathNamesPt String[]
  pathNamesEn String[]
  pathNamesEs String[]
  active      Boolean  @default(true)
  sort        Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  products Product[]
  services ServiceOffering[]

  @@index([slug])
  @@index([kind, level])
  @@index([parentId])
  @@index([pathSlugs], type: Gin)
}

model CategorySpec {
  id           String   @id @default(cuid())
  categoryId   String
  version      String // semântico, ex: 1.0.0
  inheritsFrom String? // opcional (outro categoryId)
  jsonSchema   Json
  uiSchema     Json
  indexHints   String[]
  createdAt    DateTime @default(now())

  @@unique([categoryId, version])
  @@index([categoryId])
}

model Product {
  id                    String        @id @default(uuid())
  daoId                 String
  title                 String
  description           String?
  priceBzr              Decimal       @db.Decimal(20, 12)
  categoryId            String
  categoryPath          String[]
  attributes            Json
  attributesSpecVersion String
  sellerUserId          String?
  sellerStoreId         String?
  onChainStoreId        BigInt?       @db.BigInt
  status                ProductStatus @default(PUBLISHED)
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  // === Shipping & Delivery (PROPOSAL-000) ===
  estimatedDeliveryDays Int?    @default(7) // Prazo estimado em dias úteis (legacy, usar shippingOptions)
  shippingMethod        String? // SEDEX | PAC | ... (legacy, usar shippingOptions)
  weight                Float?  @db.Real // Peso em kg
  dimensions            Json? // { length, width, height } em cm

  // === Multiple Shipping Options (PROPOSAL-002) ===
  shippingOptions ProductShippingOption[]

  category    Category       @relation(fields: [categoryId], references: [id])
  sellerStore SellerProfile? @relation(fields: [sellerStoreId], references: [id])

  @@index([daoId])
  @@index([categoryId])
  @@index([categoryPath], type: Gin)
  @@index([title])
  @@index([description])
  @@index([attributes], type: Gin)
  @@index([priceBzr])
  @@index([createdAt])
  @@index([sellerUserId])
  @@index([status])
  @@index([sellerStoreId])
  @@index([onChainStoreId])
  @@index([shippingMethod])
}

// === PROPOSAL-002: Multiple Shipping Options per Product ===
model ProductShippingOption {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Método de envio
  method String // SEDEX | PAC | TRANSPORTADORA | MINI_ENVIOS | RETIRADA | INTERNACIONAL | OUTRO
  label  String? // Nome customizado (ex: "Entrega Expressa")

  // Preço do frete
  pricingType  String   @default("FIXED") // FIXED | FREE | FREE_ABOVE | TO_ARRANGE
  priceBzr     Decimal? @db.Decimal(20, 12) // Valor fixo (quando FIXED ou FREE_ABOVE)
  freeAboveBzr Decimal? @db.Decimal(20, 12) // Grátis acima de X (quando FREE_ABOVE)

  // Prazo
  estimatedDeliveryDays Int @default(7)

  // Retirada em loja (quando method = RETIRADA)
  pickupAddressType String? @default("STORE") // STORE | CUSTOM
  pickupAddress     Json? // Se CUSTOM: { street, number, city, state, zipCode, instructions? }

  // Ordenação e status
  isDefault Boolean @default(false) // Opção padrão selecionada no checkout
  isActive  Boolean @default(true)
  sortOrder Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([productId, isActive])
  @@index([productId, sortOrder])
}

model ServiceOffering {
  id                    String   @id @default(uuid())
  daoId                 String
  title                 String
  description           String?
  basePriceBzr          Decimal? @db.Decimal(20, 12)
  categoryId            String
  categoryPath          String[]
  attributes            Json
  attributesSpecVersion String
  sellerStoreId         String?
  onChainStoreId        BigInt?  @db.BigInt
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  category    Category       @relation(fields: [categoryId], references: [id])
  sellerStore SellerProfile? @relation(fields: [sellerStoreId], references: [id])

  @@index([daoId])
  @@index([categoryId])
  @@index([categoryPath], type: Gin)
  @@index([title])
  @@index([description])
  @@index([attributes], type: Gin)
  @@index([basePriceBzr])
  @@index([createdAt])
  @@index([sellerStoreId])
  @@index([onChainStoreId])
}

model AuditLog {
  id        String   @id @default(cuid())
  entity    String
  entityId  String
  actor     String?
  action    String
  diff      Json?
  ip        String?
  ua        String?
  createdAt DateTime @default(now())

  @@index([entity, entityId])
  @@index([createdAt])
}

model User {
  id        String   @id @default(uuid())
  address   String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // TODO: Integrar com sistema de governance/conselho para aprovação de apps
  // Por enquanto usando role simples para admins
  role      String   @default("USER") // "USER" | "ADMIN" | "MODERATOR"

  refreshTokens RefreshToken[]

  // Perfis (1:1) e Lojas (1:N)
  profile        Profile?
  sellerProfiles SellerProfile[]

  // Relacionamentos DAO (owner)
  daosOwned Dao[]

  // Notificações
  notifications Notification[]

  // Interações (para feed algorítmico)
  interactions UserInteraction[]

  // Achievements
  achievements UserAchievement[]

  // Quests
  quests UserQuest[]

  // Reports
  reportsCreated  ContentReport[] @relation("reporter")
  reportsReviewed ContentReport[] @relation("reviewer")

  // Block & Mute
  blocking  UserBlock[] @relation("blocker")
  blockedBy UserBlock[] @relation("blocked")
  muting    UserMute[]  @relation("muter")
  mutedBy   UserMute[]  @relation("muted")

  // Social Auth (Fase 1)
  socialAccount SocialAccount?
  managedWallet ManagedWallet?

  // OAuth Multi-Conta (Fase 2)
  socialBackups SocialBackup[]

  // VR Integration
  vrTokens VRToken[]

  // BazariOS Developer Portal
  developerApps ThirdPartyApp[] @relation("DeveloperApps")
  appReviews    AppReview[]     @relation("AppReviews")
  appPurchases  AppPurchase[]   @relation("UserAppPurchases")
}

model SocialAccount {
  id         String   @id @default(uuid())
  userId     String   @unique
  provider   String // "google" | "email" (futuro)
  providerId String // Google sub ou email hash
  email      String?
  name       String? // Nome do usuário do Google
  picture    String? // Avatar URL do Google
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerId])
  @@index([email])
  @@index([providerId])
}

model ManagedWallet {
  id                String   @id @default(uuid())
  userId            String   @unique
  encryptedMnemonic String // Mnemonic criptografado com ENCRYPTION_KEY
  iv                String // Initialization vector para AES
  salt              String // Salt usado na derivação de chave
  authTag           String // Auth tag para GCM
  address           String // Address SR25519 derivado
  sentToClient      Boolean  @default(false) // Flag: mnemonic já foi enviado para cliente?
  isPinSetup        Boolean  @default(false) // Flag: PIN foi configurado pelo usuário?
  legacyServerSeed  Boolean  @default(false) // Flag: wallet criado com geração server-side (legacy)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([address])
}

// OAuth Multi-Conta: Múltiplos backups E2EE por usuário OAuth
model SocialBackup {
  id     String @id @default(uuid())
  userId String // Múltiplos backups por user OAuth (não unique!)

  // Identificação da conta
  accountName  String // "Conta Principal", "Loja Online", etc
  accountIndex Int // 1, 2, 3... (auto-incrementado por userId)
  address      String @unique // Address SR25519 único

  // E2EE Backup (cifrado client-side com PIN do usuário)
  encryptedMnemonic String // Blob opaco cifrado
  iv                String // Initialization vector
  salt              String // Salt para PBKDF2
  authTag           String // GCM auth tag
  iterations        Int    @default(150000) // PBKDF2 iterations

  // Metadata
  createdAt         DateTime @default(now())
  lastUsedAt        DateTime @default(now()) // Atualizado a cada restore
  deviceFingerprint String? // Opcional: identificar device que criou

  // Soft delete
  isActive Boolean @default(true)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, accountIndex]) // Uma conta por índice por usuário
  @@index([userId, isActive]) // Lista contas ativas
  @@index([address])
  @@index([lastUsedAt])
}

model AuthNonce {
  id        String    @id @default(uuid())
  address   String
  nonce     String    @unique
  domain    String
  uri       String
  genesis   String
  issuedAt  DateTime
  expiresAt DateTime
  usedAt    DateTime?

  @@index([address])
}

model RefreshToken {
  id        String    @id @default(uuid())
  userId    String
  tokenHash String    @unique
  createdAt DateTime  @default(now())
  revokedAt DateTime?
  user      User      @relation(fields: [userId], references: [id])

  @@index([userId])
}

enum OrderStatus {
  CREATED
  PENDING
  PENDING_BLOCKCHAIN // Order criada no DB, aguardando sync on-chain
  BLOCKCHAIN_FAILED // Falha ao criar on-chain (retry pendente)
  ESCROWED
  SHIPPED
  RELEASED
  REFUNDED
  CANCELLED
  TIMEOUT
}

enum PaymentIntentStatus {
  PENDING
  FUNDS_IN
  RELEASED
  REFUNDED
  TIMEOUT
  CANCELLED
}

// Publicação/status de produtos
enum ProductStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

// Status de posts
enum PostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum NotificationType {
  FOLLOW
  LIKE
  REPOST
  COMMENT
  MENTION
  BADGE
  REPUTATION
  ACHIEVEMENT_UNLOCKED
  GROUP_INVITE
  GROUP_JOIN_REQUEST
  // App Store notifications
  APP_APPROVED
  APP_REJECTED
  APP_UNPUBLISHED
}

// === PROPOSAL-003: Multi-Store Checkout Session ===
model CheckoutSession {
  id        String                @id @default(cuid())
  buyerAddr String
  status    CheckoutSessionStatus @default(PENDING)
  orders    Order[]               @relation("CheckoutSessionOrders")

  // Batch transaction info
  batchTxHash String?
  totalBzr    Decimal @db.Decimal(30, 0)

  createdAt DateTime  @default(now())
  expiresAt DateTime
  paidAt    DateTime?

  @@index([buyerAddr, status])
  @@index([batchTxHash])
  @@index([expiresAt])
}

enum CheckoutSessionStatus {
  PENDING
  PAID
  FAILED
  EXPIRED
}

model Order {
  id               String      @id @default(uuid())
  buyerAddr        String
  sellerAddr       String
  sellerId         String // DAO ID do vendedor
  sellerStoreId    String?
  subtotalBzr      Decimal     @db.Decimal(30, 0) // subtotal em planck
  shippingBzr      Decimal     @db.Decimal(30, 0) // frete em planck
  totalBzr         Decimal     @db.Decimal(30, 0) // total em planck
  status           OrderStatus @default(CREATED)
  shippingAddress  Json? // endereço de entrega
  shippingOptionId String? // ID da opção de frete
  notes            String? // observações do pedido
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  // === Shipping & Delivery (PROPOSAL-000) ===
  estimatedDeliveryDays Int?      @default(7) // Prazo estimado (copiado do produto ou informado)
  shippingMethod        String? // Método de envio selecionado
  shippedAt             DateTime? // Quando foi marcado como enviado
  trackingCode          String? // Código de rastreamento

  // === Delivery-Aware Escrow (PROPOSAL-001) ===
  autoReleaseBlocks     Int       @default(100800) // Blocos para auto-release (default 7 dias = 100,800)
  estimatedDeliveryDate DateTime? // Data estimada de entrega calculada

  // === PROPOSAL-003: Multi-Store Checkout ===
  checkoutSessionId String?
  checkoutSession   CheckoutSession? @relation("CheckoutSessionOrders", fields: [checkoutSessionId], references: [id])

  // ✅ NEW: Blockchain reference (bazari-commerce pallet)
  blockchainOrderId BigInt?   @db.BigInt // On-chain OrderId (u64)
  blockchainTxHash  String? // Transaction hash when created on-chain
  onChainStatus     String? // Cache of on-chain status (PENDING, CONFIRMED, etc)
  lastSyncedAt      DateTime? // Last time synced with blockchain
  blockchainRetries Int       @default(0) // Number of retry attempts for blockchain sync
  blockchainError   String? // Last error message from blockchain sync attempt

  items          OrderItem[]
  paymentIntents PaymentIntent[]
  escrowLogs     EscrowLog[]

  // === Delivery Relation ===
  deliveryRequest DeliveryRequest?

  @@index([buyerAddr])
  @@index([sellerAddr])
  @@index([sellerId])
  @@index([sellerStoreId])
  @@index([status])
  @@index([createdAt])
  @@index([blockchainOrderId])
  @@index([shippedAt])
  @@index([checkoutSessionId])
}

model OrderItem {
  id                   String   @id @default(cuid())
  orderId              String
  listingId            String // ID do produto/serviço
  kind                 String // 'product' | 'service'
  qty                  Int
  unitPriceBzrSnapshot Decimal  @db.Decimal(30, 0) // preço unitário em planck no momento do pedido
  titleSnapshot        String // título no momento do pedido
  lineTotalBzr         Decimal  @db.Decimal(30, 0) // qty * unitPrice em planck
  createdAt            DateTime @default(now())

  // === PROPOSAL-002: Snapshot da opção de envio selecionada ===
  shippingOptionId              String? // ID da ProductShippingOption selecionada
  shippingMethodSnapshot        String? // Método no momento do pedido
  shippingPriceBzrSnapshot      Decimal? @db.Decimal(30, 0) // Preço do frete em planck
  estimatedDeliveryDaysSnapshot Int? // Prazo no momento do pedido

  order Order @relation(fields: [orderId], references: [id])

  @@index([orderId])
  @@index([listingId])
  @@index([kind])
}

model PaymentIntent {
  id            String              @id @default(cuid())
  orderId       String
  amountBzr     Decimal             @db.Decimal(30, 0) // planck
  escrowAddress String
  status        PaymentIntentStatus @default(PENDING)
  txHashIn      String? // hash do depósito
  txHashRelease String?
  txHashRefund  String?
  createdAt     DateTime            @default(now())

  // ✅ NEW: Blockchain reference (bazari-escrow pallet)
  escrowId BigInt? @db.BigInt // On-chain escrow ID (order_id used as key)
  txHash   String? // Real transaction hash from bazari-escrow (replaces MOCK)

  order Order @relation(fields: [orderId], references: [id])

  @@index([orderId])
  @@index([status])
  @@index([createdAt])
  @@index([txHash])
}

model EscrowLog {
  id          String   @id @default(cuid())
  orderId     String
  kind        String // 'RELEASE_REQUEST' | 'REFUND_REQUEST' | 'TIMEOUT' | ...
  payloadJson Json
  createdAt   DateTime @default(now())

  order Order @relation(fields: [orderId], references: [id])

  @@index([orderId])
  @@index([kind])
  @@index([createdAt])
}

/// --- Social / Profiles ---

model Profile {
  id             String   @id @default(cuid())
  userId         String   @unique
  user           User     @relation(fields: [userId], references: [id])
  handle         String   @unique
  displayName    String
  bio            String?  @db.Text
  avatarUrl      String?
  bannerUrl      String?
  externalLinks  Json?
  followersCount Int      @default(0)
  followingCount Int      @default(0)
  postsCount     Int      @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // === NFT/Identidade Soberana ===
  onChainProfileId BigInt?   @unique @db.BigInt
  reputationScore  Int       @default(0)
  reputationTier   String    @default("bronze")
  isVerified       Boolean   @default(false)
  lastChainSync    DateTime?

  // === Monetização (MOCK) ===
  cashbackBalance String @default("0") // BZR cashback balance (MOCK)

  // === Chat E2EE ===
  chatPublicKey String? // Curve25519 public key (base64) for E2EE chat

  // Relations
  posts                 Post[]
  postComments          PostComment[]
  postReposts           PostRepost[]
  postReactions         PostReaction[]
  commentLikes          PostCommentLike[]
  followers             Follow[]                 @relation("follows_following")
  following             Follow[]                 @relation("follows_follower")
  badges                ProfileBadge[]
  reputationEvents      ProfileReputationEvent[]
  handleHistory         HandleHistory[]
  notificationsAsActor  Notification[]           @relation("NotificationActor")
  affiliates            ChatStoreAffiliate[]
  affiliateMarketplaces AffiliateMarketplace[]   @relation("AffiliateMarketplaces")

  // === Delivery Relations ===
  deliveryProfile             DeliveryProfile?
  deliveryRequestsAsDeliverer DeliveryRequest[]      @relation("DeliveryPerson")
  storePartnerships           StoreDeliveryPartner[] @relation("StoreDeliveryPartner")

  // === Rewards Relations (Blockchain Gamification) ===
  missionProgress UserMissionProgress[]
  cashbackGrants  CashbackGrant[]

  // === Developer Apps (SDK External Apps) ===
  developerApps DeveloperApp[] @relation("DeveloperApps")

  @@index([onChainProfileId])
  @@index([reputationScore])
  @@index([reputationTier])
}

model Follow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower  Profile @relation("follows_follower", fields: [followerId], references: [id])
  following Profile @relation("follows_following", fields: [followingId], references: [id])

  @@unique([followerId, followingId])
  @@index([followingId])
}

model SellerProfile {
  id                String   @id @default(cuid())
  userId            String
  user              User     @relation(fields: [userId], references: [id])
  shopName          String
  shopSlug          String   @unique
  about             String?  @db.Text
  ratingAvg         Float    @default(0)
  ratingCount       Int      @default(0)
  policies          Json?
  avatarUrl         String?
  bannerUrl         String?
  isDefault         Boolean  @default(false)
  onChainStoreId    BigInt?  @db.BigInt
  ownerAddress      String?
  operatorAddresses String[] @default([])
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // === Campos de Sincronização On-Chain ===
  syncStatus      String?   @default("pending") // 'pending' | 'syncing' | 'synced' | 'error'
  version         Int?      @default(0) // versão incremental da loja on-chain
  lastSyncBlock   BigInt?   @db.BigInt // último bloco onde foi feita sincronização
  lastPublishedAt DateTime? // timestamp da última publicação on-chain

  // === Address for Pickup ===
  pickupAddress Json? // { street, number, complement?, city, state, zipCode, lat?, lng?, instructions? }

  // Relations
  products        Product[]
  services        ServiceOffering[]
  publishHistory  StorePublishHistory[]
  land            Land? // VR: Relação 1:1 com terreno virtual
  pluginInstances PluginInstance[] // Plugins instalados na loja

  @@index([userId])
  @@index([onChainStoreId])
  @@index([ownerAddress])
  @@index([operatorAddresses], type: Gin)
  @@index([syncStatus])
}

model Post {
  id        String     @id @default(cuid())
  authorId  String
  author    Profile    @relation(fields: [authorId], references: [id])
  kind      String // 'text' | 'image' | 'link' (MVP: text)
  content   String     @db.Text
  media     Json?
  status    PostStatus @default(PUBLISHED)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  likes     PostLike[]
  reposts   PostRepost[]
  reactions PostReaction[]
  comments  PostComment[]

  @@index([authorId, createdAt])
  @@index([status])
}

model PostLike {
  id        String   @id @default(cuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  profileId String
  createdAt DateTime @default(now())

  @@unique([postId, profileId])
  @@index([postId])
  @@index([profileId])
}

model PostRepost {
  id        String   @id @default(cuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  profileId String
  profile   Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([postId, profileId])
  @@index([postId])
  @@index([profileId])
}

model PostReaction {
  id        String   @id @default(cuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  profileId String
  profile   Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)
  reaction  String // love, laugh, wow, sad, angry
  createdAt DateTime @default(now())

  @@unique([postId, profileId])
  @@index([postId])
  @@index([profileId])
  @@index([postId, reaction])
}

model PostComment {
  id        String   @id @default(cuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  authorId  String
  author    Profile  @relation(fields: [authorId], references: [id], onDelete: Cascade)
  content   String   @db.Text
  parentId  String? // Para respostas aninhadas
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  parent  PostComment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies PostComment[]     @relation("CommentReplies")
  likes   PostCommentLike[]

  @@index([postId, createdAt])
  @@index([authorId])
  @@index([parentId])
}

model PostCommentLike {
  id        String      @id @default(cuid())
  commentId String
  comment   PostComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  profileId String
  profile   Profile     @relation(fields: [profileId], references: [id], onDelete: Cascade)
  createdAt DateTime    @default(now())

  @@unique([commentId, profileId])
  @@index([commentId])
  @@index([profileId])
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  actorId   String?
  actor     Profile?         @relation("NotificationActor", fields: [actorId], references: [id], onDelete: Cascade)
  targetId  String? // ID do post, comment, badge, etc
  metadata  Json? // Dados adicionais específicos do tipo
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())

  @@index([userId, read, createdAt])
  @@index([createdAt])
}

model ProfileBadge {
  id           String    @id @default(cuid())
  profileId    String
  profile      Profile   @relation(fields: [profileId], references: [id], onDelete: Cascade)
  code         String
  label        Json // {pt, en, es}
  issuedBy     String // marketplace, dao, system, etc
  issuedAt     DateTime
  blockNumber  BigInt    @db.BigInt
  revokedAt    DateTime?
  revokeReason String?

  @@unique([profileId, code])
  @@index([profileId])
  @@index([code])
  @@index([issuedAt])
}

model ProfileReputationEvent {
  id          String   @id @default(cuid())
  profileId   String
  profile     Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)
  eventCode   String // ORDER_COMPLETED, DELIVERY_DONE, etc
  delta       Int
  newTotal    Int
  reason      String?
  emittedBy   String // marketplace, delivery, social, etc
  blockNumber BigInt   @db.BigInt
  extrinsicId String?
  createdAt   DateTime @default(now())

  @@index([profileId, createdAt])
  @@index([eventCode])
  @@index([blockNumber])
}

model HandleHistory {
  id          String   @id @default(cuid())
  profileId   String
  profile     Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)
  oldHandle   String?
  newHandle   String
  changedAt   DateTime
  blockNumber BigInt   @db.BigInt

  @@index([profileId, changedAt])
  @@index([newHandle])
}

model Dao {
  id          String  @id @default(cuid())
  name        String
  slug        String  @unique
  ownerUserId String?
  owner       User?   @relation(fields: [ownerUserId], references: [id])

  @@index([ownerUserId])
}

model SubDao {
  id          String @id @default(cuid())
  daoId       String
  name        String
  slug        String @unique
  ownerUserId String // User.id (dono/admin)

  @@index([ownerUserId])
}

model ProfileSubDao {
  id        String   @id @default(cuid())
  profileId String
  subDaoId  String
  role      String // 'owner' | 'admin' | 'member'
  createdAt DateTime @default(now())

  @@unique([profileId, subDaoId])
}

/// --- P2P (Offers / Orders) ---

enum P2POfferSide {
  BUY_BZR
  SELL_BZR
}

enum P2POfferStatus {
  ACTIVE
  PAUSED
  ARCHIVED
}

enum P2POrderStatus {
  DRAFT
  AWAITING_ESCROW
  AWAITING_FIAT_PAYMENT
  AWAITING_CONFIRMATION
  RELEASED
  EXPIRED
  CANCELLED
  DISPUTE_OPEN
  DISPUTE_RESOLVED_BUYER
  DISPUTE_RESOLVED_SELLER
}

enum P2PPaymentMethod {
  PIX
}

// FASE 5: Asset types for P2P trading
enum P2PAssetType {
  BZR
  ZARI
}

model P2PPaymentProfile {
  id          String   @id @default(cuid())
  userId      String   @unique
  pixKey      String?
  bankName    String?
  accountName String?
  updatedAt   DateTime @updatedAt
  createdAt   DateTime @default(now())
}

model P2POffer {
  id      String       @id @default(cuid())
  ownerId String
  side    P2POfferSide

  // FASE 5: Asset being traded
  assetType P2PAssetType @default(BZR)
  assetId   String? // '1' for ZARI, null for BZR

  // FASE 5: Phase info (only for ZARI)
  phase      String? // '2A' | '2B' | '3' | null
  phasePrice Decimal? @db.Decimal(18, 12) // 0.25 | 0.35 | 0.50 (in BZR)

  // Pricing (now generic)
  priceBRLPerBZR  Decimal  @db.Decimal(18, 2) // Deprecated, use priceBRLPerUnit
  priceBRLPerUnit Decimal? @db.Decimal(18, 2) // R$/BZR or R$/ZARI
  minBRL          Decimal  @db.Decimal(18, 2)
  maxBRL          Decimal  @db.Decimal(18, 2)

  method    P2PPaymentMethod
  autoReply String?
  status    P2POfferStatus   @default(ACTIVE)

  // FASE 5: Expanded stats
  stats Json? // { totalSold, totalVolume, phaseSupplyLeft }

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerId, status, side])
  @@index([ownerId, status, side, assetType])
  @@index([assetType, phase, status])
}

model P2POrder {
  id      String       @id @default(cuid())
  offerId String
  makerId String
  takerId String
  side    P2POfferSide

  // FASE 5: Asset info
  assetType P2PAssetType @default(BZR)
  assetId   String? // '1' for ZARI
  phase     String? // '2A', '2B', '3'

  // Pricing
  priceBRLPerBZR  Decimal  @db.Decimal(18, 2) // Deprecated, use priceBRLPerUnit
  priceBRLPerUnit Decimal? @db.Decimal(18, 2)
  amountBZR       Decimal  @db.Decimal(38, 18) // Deprecated, use amountAsset
  amountAsset     Decimal? @db.Decimal(38, 18) // BZR or ZARI
  amountBRL       Decimal  @db.Decimal(18, 2)

  method P2PPaymentMethod
  status P2POrderStatus   @default(DRAFT)

  // Escrow on-chain
  escrowTxHash   String?
  escrowAt       DateTime?
  releasedTxHash String?
  releasedAt     DateTime?

  // PIX proof
  pixKeySnapshot  String?
  payerDeclaredAt DateTime?
  proofUrls       Json?

  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([makerId, takerId, status])
  @@index([makerId, takerId, status, assetType])
  @@index([offerId])
  @@index([assetType, phase])
}

model P2PMessage {
  id        String   @id @default(cuid())
  orderId   String
  senderId  String
  body      String   @db.Text
  kind      String
  createdAt DateTime @default(now())

  @@index([orderId, createdAt])
}

model P2PDispute {
  id         String   @id @default(cuid())
  orderId    String   @unique
  openedById String
  reason     String
  evidence   Json?
  status     String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model P2PReview {
  id        String   @id @default(cuid())
  orderId   String   @unique
  raterId   String
  rateeId   String
  stars     Int
  comment   String?
  createdAt DateTime @default(now())
}

// FASE 5: ZARI Phase Configuration
model ZARIPhaseConfig {
  id          String   @id @default(cuid())
  phase       String   @unique // '2A', '2B', '3'
  priceBZR    Decimal  @db.Decimal(18, 12) // 0.25, 0.35, 0.50
  supplyLimit BigInt // 2_100_000 * 10^12 (decimals)
  startBlock  BigInt? // Block number when phase started
  endBlock    BigInt? // Block number when phase ended
  active      Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([phase, active])
}

/// --- Store Publishing History ---

model StorePublishHistory {
  id              String        @id @default(cuid())
  sellerProfileId String
  sellerProfile   SellerProfile @relation(fields: [sellerProfileId], references: [id], onDelete: Cascade)
  version         Int // versão incremental
  blockNumber     BigInt        @db.BigInt // bloco em que foi publicado
  extrinsicHash   String? // hash da extrinsic do publish_store
  publishedAt     DateTime      @default(now())

  @@index([sellerProfileId, version])
  @@index([blockNumber])
  @@index([publishedAt])
}

// User Interactions for Feed Algorithm
model UserInteraction {
  id              String   @id @default(cuid())
  userId          String
  targetType      String // POST, PROFILE, PRODUCT
  targetId        String
  interactionType String // VIEW, LIKE, COMMENT, SHARE
  weight          Float    @default(1.0)
  createdAt       DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([targetType, targetId])
  @@index([userId, targetType])
}

model TrendingTopic {
  id         String   @id @default(cuid())
  tag        String   @unique
  count      Int      @default(0)
  score      Float    @default(0)
  growthRate Float? // Taxa de crescimento vs período anterior
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([score(sort: Desc), updatedAt])
  @@index([updatedAt])
}

model Achievement {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String   @db.Text
  category    String // SOCIAL, ENGAGEMENT, CONTENT, STREAK
  tier        Int      @default(1) // 1-5 (Bronze to Diamond)
  requirement Json // { type: "POST_COUNT", value: 1 }
  icon        String? // Emoji ou URL
  createdAt   DateTime @default(now())

  userAchievements UserAchievement[]

  @@index([category, tier])
}

model UserAchievement {
  id            String    @id @default(cuid())
  userId        String
  achievementId String
  progress      Int       @default(0) // Progresso atual
  unlockedAt    DateTime? // null = ainda bloqueado
  createdAt     DateTime  @default(now())

  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([userId, unlockedAt])
  @@index([achievementId])
}

model Quest {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String   @db.Text
  type        String // POST, LIKE, COMMENT, FOLLOW
  target      Int // Quantidade necessária
  reward      Int // Pontos de reward
  icon        String?
  createdAt   DateTime @default(now())

  userQuests UserQuest[]

  @@index([type])
}

model UserQuest {
  id          String    @id @default(cuid())
  userId      String
  questId     String
  progress    Int       @default(0)
  completedAt DateTime? // null = não completado
  claimedAt   DateTime? // null = reward não reivindicado
  date        String // YYYY-MM-DD para track diário
  createdAt   DateTime  @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  quest Quest @relation(fields: [questId], references: [id], onDelete: Cascade)

  @@unique([userId, questId, date])
  @@index([userId, date])
  @@index([questId, date])
}

enum ReportReason {
  SPAM
  HARASSMENT
  INAPPROPRIATE
  MISINFORMATION
  VIOLENCE
  OTHER
}

enum ReportStatus {
  PENDING
  REVIEWED
  RESOLVED
  DISMISSED
}

model ContentReport {
  id          String       @id @default(cuid())
  reporterId  String
  contentType String // POST, COMMENT, PROFILE
  contentId   String
  reason      ReportReason
  details     String?      @db.Text
  status      ReportStatus @default(PENDING)
  reviewedBy  String?
  reviewedAt  DateTime?
  createdAt   DateTime     @default(now())

  reporter User  @relation("reporter", fields: [reporterId], references: [id], onDelete: Cascade)
  reviewer User? @relation("reviewer", fields: [reviewedBy], references: [id])

  @@index([status, createdAt])
  @@index([contentType, contentId])
  @@index([reporterId])
}

model UserBlock {
  id            String   @id @default(cuid())
  userId        String
  blockedUserId String
  createdAt     DateTime @default(now())

  user        User @relation("blocker", fields: [userId], references: [id], onDelete: Cascade)
  blockedUser User @relation("blocked", fields: [blockedUserId], references: [id], onDelete: Cascade)

  @@unique([userId, blockedUserId])
  @@index([userId])
  @@index([blockedUserId])
}

model UserMute {
  id          String   @id @default(cuid())
  userId      String
  mutedUserId String
  createdAt   DateTime @default(now())

  user      User @relation("muter", fields: [userId], references: [id], onDelete: Cascade)
  mutedUser User @relation("muted", fields: [mutedUserId], references: [id], onDelete: Cascade)

  @@unique([userId, mutedUserId])
  @@index([userId])
  @@index([mutedUserId])
}

// ===========================
// BazChat Models (FASE 0)
// ===========================

model ChatThread {
  id            String   @id @default(uuid())
  kind          String // dm | store | order | group
  participants  String[] // profileIds
  orderId       String?
  groupId       String?
  lastMessageAt BigInt
  metadata      Json?
  createdAt     BigInt
  updatedAt     BigInt

  messages  ChatMessage[]
  proposals ChatProposal[]

  @@index([participants])
  @@index([lastMessageAt(sort: Desc)])
  @@index([kind])
}

model ChatMessage {
  id          String  @id @default(uuid())
  threadId    String
  fromProfile String
  type        String // text | audio | image | file | video | proposal | checkout | payment | system
  ciphertext  String  @db.Text
  mediaCid    String?
  meta        Json?
  createdAt   BigInt
  deliveredAt BigInt?
  readAt      BigInt?
  replyTo     String?
  editedAt    BigInt?

  thread ChatThread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@index([threadId, createdAt(sort: Desc)])
  @@index([fromProfile])
  @@index([type])
}

model ChatGroup {
  id          String   @id @default(uuid())
  name        String
  description String?
  avatarUrl   String?
  kind        String   @default("community") // community | channel | dao
  isPublic    Boolean  @default(false)
  adminIds    String[]
  memberIds   String[]
  maxMembers  Int?     @default(500)
  metadata    Json?
  createdAt   BigInt

  @@index([adminIds])
  @@index([memberIds])
  @@index([kind])
  @@index([isPublic])
}

model ChatProposal {
  id                String  @id @default(uuid())
  threadId          String
  sellerId          String
  buyerId           String?
  items             Json // ProposalItem[]
  subtotal          Decimal @db.Decimal(20, 8)
  shipping          Json?
  total             Decimal @db.Decimal(20, 8)
  commissionPercent Int

  // Multi-Store Support
  isMultiStore Boolean @default(false)
  storeGroups  Json? // Array de StoreGroup[]

  status    String  @default("draft") // draft | sent | accepted | expired | paid
  expiresAt BigInt?
  createdAt BigInt
  updatedAt BigInt

  thread ChatThread      @relation(fields: [threadId], references: [id])
  sales  AffiliateSale[]

  @@index([threadId])
  @@index([sellerId])
  @@index([status])
}

model StoreCommissionPolicy {
  storeId            BigInt   @id
  mode               String   @default("open") // open | followers | affiliates
  percent            Int      @default(5)
  minReputation      Int?
  dailyCommissionCap Decimal? @db.Decimal(20, 8)
  allowMultiStore    Boolean  @default(true) // FASE 8: Multi-Store Proposals
  createdAt          BigInt
  updatedAt          BigInt
}

model ChatMission {
  id             String                  @id @default(uuid())
  title          String
  description    String
  reward         Decimal                 @db.Decimal(20, 8)
  type           String // share | review | referral | custom
  kind           String                  @default("custom") // onboarding | referral | sales | engagement
  goal           Int                     @default(1) // Quantidade necessária para completar
  requirements   Json?
  maxCompletions Int?
  completedCount Int                     @default(0)
  expiresAt      BigInt?
  status         String                  @default("active") // active | paused | completed
  isActive       Boolean                 @default(true)
  createdBy      String
  createdAt      BigInt
  completions    ChatMissionCompletion[]

  @@index([status, expiresAt])
  @@index([createdBy])
  @@index([isActive])
}

model ChatMissionCompletion {
  profileId   String
  missionId   String
  progress    Int         @default(0)
  completedAt BigInt?
  mission     ChatMission @relation(fields: [missionId], references: [id], onDelete: Cascade)

  @@id([profileId, missionId])
  @@index([profileId])
  @@index([missionId])
}

model ChatOpportunity {
  id           String  @id @default(uuid())
  storeId      BigInt
  title        String
  description  String
  type         String // job | freelance | partnership
  compensation String?
  requirements Json?
  status       String  @default("open") // open | filled | closed
  createdAt    BigInt
  expiresAt    BigInt?

  @@index([storeId])
  @@index([status])
}

// AffiliateSale - MOCK de vendas on-chain (FASE 3)
// Esta tabela simula o que seria armazenado na blockchain
// Será substituída por integração real posteriormente
model AffiliateSale {
  id String @id @default(uuid())

  // Link para marketplace (NOVO)
  marketplaceId String?
  marketplace   AffiliateMarketplace? @relation(fields: [marketplaceId], references: [id])

  storeId           BigInt
  buyer             String // profileId
  seller            String // profileId
  promoter          String? // profileId (opcional)
  amount            Decimal       @db.Decimal(20, 8)
  commissionPercent Int           @default(0)
  commissionAmount  Decimal       @default(0) @db.Decimal(20, 8)
  bazariFee         Decimal       @default(0) @db.Decimal(20, 8)
  sellerAmount      Decimal       @db.Decimal(20, 8)
  status            String        @default("pending") // pending, split, failed
  txHash            String? // Mock transaction hash
  receiptNftCid     String? // IPFS CID do recibo NFT
  proposalId        String?
  proposal          ChatProposal? @relation(fields: [proposalId], references: [id])
  createdAt         BigInt
  settledAt         BigInt?

  // ✅ NEW: Blockchain reference (bazari-commerce pallet)
  blockchainSaleId BigInt?   @db.BigInt // On-chain SaleId (u64)
  blockchainTxHash String? // Real transaction hash (replaces MOCK txHash)
  onChainStatus    String? // Cache of on-chain status
  lastSyncedAt     DateTime? // Last time synced with blockchain

  @@index([storeId])
  @@index([buyer])
  @@index([seller])
  @@index([promoter])
  @@index([marketplaceId]) // NOVO
  @@index([status])
  @@index([proposalId])
  @@index([createdAt(sort: Desc)])
  @@index([blockchainSaleId])
}

// === FASE 7: Social Features ===

// Trust Badges NFT (MOCK)
model ChatTrustBadge {
  id        String  @id
  profileId String
  level     String // bronze | silver | gold | platinum
  nftId     String? // Mock NFT ID
  isActive  Boolean @default(true)
  issuedAt  BigInt

  @@index([profileId])
  @@index([isActive])
}

// Denúncias e Moderação (MOCK)
model ChatReport {
  id              String  @id
  reporterId      String
  reportedId      String
  contentType     String // message | profile | group
  contentId       String
  reason          String
  description     String  @default("")
  status          String  @default("pending") // pending | under_review | resolved
  votes           Int     @default(0)
  approveVotes    Int     @default(0)
  rejectVotes     Int     @default(0)
  resolution      String? // warning | suspend | ban | dismiss
  resolvedBy      String?
  resolvedAt      BigInt?
  resolutionNotes String?
  createdAt       BigInt

  @@index([reporterId])
  @@index([reportedId])
  @@index([status])
  @@index([createdAt(sort: Desc)])
}

model ChatReportVote {
  reportId String
  voterId  String
  vote     String // approve | reject
  weight   Int    @default(1)
  votedAt  BigInt

  @@id([reportId, voterId])
  @@index([reportId])
  @@index([voterId])
}

// Polls em Grupos
model ChatGroupPoll {
  id        String  @id
  groupId   String
  creatorId String
  question  String
  options   Json // Array de opções
  votes     Json    @default("{}") // Map de voterId -> optionIndex
  endsAt    BigInt?
  createdAt BigInt

  @@index([groupId])
  @@index([createdAt(sort: Desc)])
}

// === FASE 8: Affiliate System ===

// Sistema de Afiliados - Gerenciamento de promotores aprovados
model ChatStoreAffiliate {
  id         String  @id @default(uuid())
  storeId    BigInt // ID on-chain da loja
  promoterId String // profileId do promotor
  promoter   Profile @relation(fields: [promoterId], references: [id], onDelete: Cascade)

  // Status
  status String @default("pending") // pending | approved | rejected | suspended

  // Comissão customizada (opcional - override da política geral)
  customCommission Int? // Se null, usa a política da loja

  // Limites opcionais
  monthlySalesCap Decimal? @db.Decimal(20, 8) // Limite mensal de vendas

  // Metadata
  notes String? @db.Text // Notas do dono da loja

  // Timestamps
  requestedAt BigInt // Quando solicitou
  approvedAt  BigInt? // Quando foi aprovado
  rejectedAt  BigInt? // Quando foi rejeitado
  suspendedAt BigInt? // Quando foi suspenso

  // Performance (calculado periodicamente)
  totalSales      Decimal @default(0) @db.Decimal(20, 8)
  totalCommission Decimal @default(0) @db.Decimal(20, 8)
  salesCount      Int     @default(0)

  createdAt BigInt
  updatedAt BigInt

  @@unique([storeId, promoterId])
  @@index([promoterId])
  @@index([storeId, status])
}

// Sistema de Convites de Afiliado (Opcional)
model ChatAffiliateInvite {
  id         String @id @default(uuid())
  storeId    BigInt
  inviteCode String @unique // Código único de convite

  // Configurações do convite
  maxUses   Int? // Número máximo de usos (null = ilimitado)
  usesCount Int     @default(0)
  expiresAt BigInt? // Data de expiração

  // Auto-aprovação
  autoApprove Boolean @default(false)

  // Comissão padrão para quem usar este convite
  defaultCommission Int @default(5)

  createdAt BigInt

  @@index([storeId])
}

// === MARKETPLACE DO AFILIADO ===

// Marketplace personalizado do afiliado (vitrine)
model AffiliateMarketplace {
  id      String  @id @default(uuid())
  ownerId String
  owner   Profile @relation("AffiliateMarketplaces", fields: [ownerId], references: [id], onDelete: Cascade)

  // Branding
  name           String
  slug           String  @unique
  description    String? @db.Text
  logoUrl        String?
  bannerUrl      String?
  theme          String  @default("bazari")
  primaryColor   String?
  secondaryColor String?

  // Estatísticas (cache)
  totalSales      Int     @default(0)
  totalRevenue    Decimal @default(0) @db.Decimal(20, 8)
  totalCommission Decimal @default(0) @db.Decimal(20, 8)
  productCount    Int     @default(0)

  // Status
  isActive Boolean @default(true)
  isPublic Boolean @default(true)

  createdAt BigInt
  updatedAt BigInt

  products AffiliateProduct[]
  sales    AffiliateSale[]

  @@index([ownerId])
  @@index([slug])
  @@index([isActive, isPublic])
}

// Produtos adicionados à vitrine do afiliado
model AffiliateProduct {
  id            String               @id @default(uuid())
  marketplaceId String
  marketplace   AffiliateMarketplace @relation(fields: [marketplaceId], references: [id], onDelete: Cascade)

  // Produto original
  storeId         BigInt
  productId       String
  productName     String
  productImageUrl String?
  productPrice    Decimal @db.Decimal(20, 8)

  // Comissão
  commissionPercent Int

  // Customizações (opcional)
  customDescription String? @db.Text
  customImageUrl    String?
  featured          Boolean @default(false)

  // Tracking
  viewCount  Int @default(0)
  clickCount Int @default(0)

  addedAt   BigInt
  updatedAt BigInt

  @@unique([marketplaceId, storeId, productId])
  @@index([marketplaceId])
  @@index([storeId])
}

// ===========================
// DELIVERY NETWORK (FASE 1)
// ===========================

model DeliveryRequest {
  id String @id @default(uuid())

  // Origem da demanda
  sourceType String // "order" | "direct"
  orderId    String? @unique
  order      Order?  @relation(fields: [orderId], references: [id])

  // Endereços
  pickupAddress   Json // { street, number, complement?, city, state, zipCode, country, lat?, lng?, contactName?, contactPhone? }
  deliveryAddress Json // { street, number, complement?, city, state, zipCode, country, lat?, lng?, contactName?, contactPhone? }

  // Partes Envolvidas
  senderId    String // storeId (SellerProfile.id) ou profileId
  senderType  String // "store" | "profile"
  recipientId String // profileId do destinatário

  // Detalhes da Carga
  packageType       String // "envelope" | "small_box" | "medium_box" | "large_box" | "fragile" | "perishable" | "custom"
  weight            Float?   @db.Real // em kg
  dimensions        Json? // { length: float, width: float, height: float } em cm
  estimatedValue    Decimal? @db.Decimal(20, 8) // valor estimado da mercadoria (para seguro)
  notes             String?  @db.Text
  requiresSignature Boolean  @default(true)

  // Valor e Pagamento
  deliveryFeeBzr Decimal @db.Decimal(20, 8)
  distance       Float?  @db.Real // em km (calculado)

  // Status
  status String @default("pending")
  // "pending" → "assigned" → "accepted" → "picked_up" → "in_transit" → "delivered" → "completed"
  // ou "cancelled" | "failed"

  // Entregador
  deliveryPersonId String?
  deliveryPerson   Profile? @relation("DeliveryPerson", fields: [deliveryPersonId], references: [id])

  // Rede de Entregadores
  preferredDeliverers String[] @default([]) // profileIds (ordem de prioridade)
  isPrivateNetwork    Boolean  @default(false) // true = só rede vinculada pode ver
  notifiedDeliverers  String[] @default([]) // histórico de quem foi notificado

  // Tracking de Tempo
  createdAt   BigInt
  updatedAt   BigInt
  expiresAt   BigInt? // prazo limite para aceite
  assignedAt  BigInt? // quando foi atribuído
  acceptedAt  BigInt? // quando entregador aceitou
  pickedUpAt  BigInt? // quando coletou
  inTransitAt BigInt? // quando iniciou trânsito
  deliveredAt BigInt? // quando entregou
  completedAt BigInt? // quando foi finalizado/pago
  cancelledAt BigInt?

  // Escrow e Pagamento
  escrowAddress String?
  paymentTxHash String? // hash da transação de pagamento
  releaseTxHash String? // hash da liberação do escrow

  // Prova de Entrega
  proofOfDelivery Json? // { signature?, photo_urls?: string[], timestamp: bigint }

  // Avaliação
  rating        Int? // 1-5 estrelas
  reviewComment String? @db.Text

  // Metadados
  metadata Json? // campo flexível para dados extras

  // Relations
  waypoints DeliveryWaypoint[]
  reviews   CourierReview[]

  @@index([status])
  @@index([senderId, senderType])
  @@index([deliveryPersonId])
  @@index([orderId])
  @@index([createdAt])
  @@index([isPrivateNetwork])
}

model StoreDeliveryPartner {
  id String @id @default(uuid())

  // Relação
  storeId          BigInt // SellerProfile.onChainStoreId
  deliveryPersonId String // Profile.id
  deliveryPerson   Profile @relation("StoreDeliveryPartner", fields: [deliveryPersonId], references: [id], onDelete: Cascade)

  // Configurações
  status   String @default("pending") // "pending" | "active" | "paused" | "suspended" | "rejected"
  priority Int    @default(1) // 1 = primeira oferta, 2 = segunda, etc.

  // Comissão e Financeiro
  commissionPercent Int      @default(100) // % do deliveryFeeBzr que vai para o entregador
  bonusPerDelivery  Decimal? @db.Decimal(20, 8) // bônus fixo por entrega

  // Restrições
  maxDailyDeliveries Int? // limite de entregas por dia (null = sem limite)
  allowedDays        String[] @default([]) // ["monday", "tuesday", ...] - vazio = todos os dias
  workingHoursStart  String? // "08:00"
  workingHoursEnd    String? // "18:00"

  // Métricas (cache)
  totalDeliveries     Int    @default(0)
  completedDeliveries Int    @default(0)
  cancelledDeliveries Int    @default(0)
  avgRating           Float  @default(0)
  avgDeliveryTime     Float? @db.Real // em minutos
  onTimeRate          Float  @default(100.0) // %

  // Timestamps
  requestedAt BigInt? // quando entregador solicitou
  approvedAt  BigInt? // quando loja aprovou
  rejectedAt  BigInt?
  suspendedAt BigInt?
  createdAt   BigInt
  updatedAt   BigInt

  // Notas
  notes           String? @db.Text // notas privadas da loja sobre o entregador
  rejectionReason String? @db.Text

  @@unique([storeId, deliveryPersonId])
  @@index([storeId, status])
  @@index([deliveryPersonId, status])
  @@index([priority])
}

model DeliveryProfile {
  id        String  @id @default(uuid())
  profileId String  @unique
  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  // Documentação
  fullName         String
  documentType     String // "cpf" | "cnpj" | "passport"
  documentNumber   String @unique
  phoneNumber      String
  emergencyContact Json? // { name: string, phone: string, relationship: string }

  // Veículo
  vehicleType  String // "bike" | "motorcycle" | "car" | "van" | "truck"
  vehiclePlate String?
  vehicleModel String?
  vehicleYear  Int?
  vehicleColor String?

  // Capacidades
  maxWeight          Float   @db.Real // kg
  maxVolume          Float   @db.Real // m³
  canCarryFragile    Boolean @default(false)
  canCarryPerishable Boolean @default(false)
  hasInsulatedBag    Boolean @default(false) // bag térmica

  // Disponibilidade
  isAvailable        Boolean @default(false)
  isOnline           Boolean @default(false) // conectado no momento
  currentLat         Float?  @db.Real
  currentLng         Float?  @db.Real
  currentAccuracy    Float?  @db.Real // em metros
  lastLocationUpdate BigInt?

  // Área de Atuação
  serviceRadius          Float    @default(10.0) @db.Real // km
  serviceCities          String[] @default([]) // ["Rio de Janeiro", "Niterói"]
  serviceStates          String[] @default([]) // ["RJ"]
  preferredNeighborhoods String[] @default([])

  // Estatísticas
  totalDeliveries     Int   @default(0)
  completedDeliveries Int   @default(0)
  cancelledDeliveries Int   @default(0)
  avgRating           Float @default(0)
  totalRatings        Int   @default(0)
  onTimeRate          Float @default(100.0) // %
  acceptanceRate      Float @default(100.0) // % de entregas aceitas vs oferecidas
  completionRate      Float @default(100.0) // % de entregas completadas vs aceitas

  // Performance
  avgDeliveryTime Float? @db.Real // tempo médio em minutos
  fastestDelivery Float? @db.Real // entrega mais rápida (minutos)
  totalDistance   Float  @default(0) @db.Real // km acumulados

  // Financeiro
  walletAddress   String? // endereço blockchain para receber pagamentos
  totalEarnings   Decimal @default(0) @db.Decimal(20, 8) // BZR ganhos (histórico)
  pendingEarnings Decimal @default(0) @db.Decimal(20, 8) // BZR em escrow

  // Verificação
  isVerified               Boolean @default(false)
  verificationLevel        String  @default("basic") // "basic" | "intermediate" | "advanced"
  backgroundCheckCompleted Boolean @default(false)
  backgroundCheckDate      BigInt?

  // Configurações
  autoAcceptRadius     Float?   @db.Real // km - aceita automaticamente dentro desse raio
  minDeliveryFee       Decimal? @db.Decimal(20, 8) // valor mínimo de entrega que aceita
  notificationsEnabled Boolean  @default(true)

  // Status da Conta
  accountStatus    String  @default("active") // "active" | "suspended" | "banned" | "under_review"
  suspensionReason String? @db.Text
  suspendedUntil   BigInt?

  // Timestamps
  createdAt    BigInt
  updatedAt    BigInt
  lastActiveAt BigInt?
  verifiedAt   BigInt?

  // ✅ NEW: Blockchain sync (bazari-fulfillment pallet)
  reviewsMerkleRoot      String? // Cache of on-chain Merkle root
  lastMerkleUpdate       DateTime? // Last time Merkle root was updated
  onChainReputationScore Int? // Cache of on-chain reputation score

  @@index([isAvailable, isOnline])
  @@index([profileId])
  @@index([documentNumber])
  @@index([serviceRadius])
  @@index([accountStatus])
  @@index([reviewsMerkleRoot])
}

// === DeliveryWaypoint (NEW) - GPS Tracking ===
model DeliveryWaypoint {
  id                String          @id @default(uuid())
  deliveryRequestId String
  deliveryRequest   DeliveryRequest @relation(fields: [deliveryRequestId], references: [id], onDelete: Cascade)
  latitude          Float           @db.Real
  longitude         Float           @db.Real
  accuracy          Float?          @db.Real // em metros
  altitude          Float?          @db.Real
  speed             Float?          @db.Real // m/s
  bearing           Float?          @db.Real // degrees
  timestamp         BigInt

  // ✅ NEW: Proof tracking (bazari-attestation pallet)
  proofSubmitted Boolean @default(false) // Was this waypoint part of a proof?
  proofCid       String? // IPFS CID if submitted as HandoffProof/DeliveryProof

  @@index([deliveryRequestId, timestamp])
  @@index([proofSubmitted])
}

// === CourierReview (NEW) - Off-Chain Reviews ===
model CourierReview {
  id                String          @id @default(uuid())
  deliveryRequestId String
  deliveryRequest   DeliveryRequest @relation(fields: [deliveryRequestId], references: [id], onDelete: Cascade)
  courierId         String // Profile.id (delivery person)
  reviewerId        String // Profile.id (quem avaliou: sender ou recipient)
  rating            Int // 1-5 stars
  comment           String?         @db.Text
  createdAt         BigInt

  // ✅ NEW: Merkle inclusion tracking (bazari-fulfillment pallet)
  merkleIncluded Boolean @default(false) // Was included in Merkle tree?
  merkleRootHash String? // Which Merkle root includes this review?

  @@index([courierId, createdAt])
  @@index([reviewerId])
  @@index([deliveryRequestId])
  @@index([courierId, merkleIncluded])
}

// ============================================================
// GOVERNANCE MODELS
// ============================================================

model GovernanceTreasuryRequest {
  id Int @id @default(autoincrement())

  // Dados da solicitação
  title       String @db.VarChar(255)
  description String @db.Text
  value       String @db.VarChar(50) // Valor em planck (string para precisão)
  beneficiary String @db.VarChar(66) // Endereço SS58
  proposer    String @db.VarChar(66) // Quem criou a solicitação

  // Status e tracking
  status String @default("PENDING_REVIEW") @db.VarChar(50)
  // PENDING_REVIEW: Aguardando council analisar
  // IN_VOTING: Motion criado, aguardando votos
  // APPROVED: Motion aprovado, spend executado
  // REJECTED: Motion rejeitado pelo council
  // PAID_OUT: Pagamento realizado

  // Linkagem com blockchain
  councilMotionHash  String? @db.VarChar(66) // Hash do motion criado
  councilMotionIndex Int? // Índice do motion
  spendId            Int? // ID do spend aprovado on-chain
  txHash             String? @db.VarChar(66) // Hash da tx de aprovação
  blockNumber        Int? // Bloco de aprovação

  // Assinatura para validação
  signature String @db.Text

  // Timestamps
  createdAt  DateTime  @default(now())
  reviewedAt DateTime?
  approvedAt DateTime?
  paidOutAt  DateTime?

  @@index([status])
  @@index([proposer])
  @@index([councilMotionHash])
  @@index([createdAt(sort: Desc)])
  @@map("governance_treasury_requests")
}

model GovernanceCouncilVote {
  id Int @id @default(autoincrement())

  motionHash  String  @db.VarChar(66)
  motionIndex Int
  voter       String  @db.VarChar(66) // Council member que votou
  vote        Boolean // true = AYE, false = NAY

  txHash      String   @db.VarChar(66)
  blockNumber Int
  timestamp   DateTime @default(now())

  @@unique([motionHash, motionIndex, voter])
  @@index([motionHash, motionIndex])
  @@map("governance_council_votes")
}

// Tabela para salvar propostas Democracy quando criadas
model GovernanceDemocracyProposal {
  id Int @id @default(autoincrement())

  // Dados da proposta on-chain
  proposalIndex Int     @unique
  proposalHash  String  @db.VarChar(66) // Hash da proposta
  preimageHash  String? @db.VarChar(66) // Hash do preimage (se disponível)

  // Metadata extraído do preimage/remark
  title       String  @db.VarChar(255)
  description String  @db.Text
  proposer    String? @db.VarChar(66) // Quem propôs

  // Dados financeiros
  deposit String @db.VarChar(50) // Depósito em planck

  // Status
  status String @default("PROPOSED") @db.VarChar(50)
  // PROPOSED: Proposta criada, aguardando endorsements
  // STARTED: Virou referendum (migrado para GovernanceReferendum)
  // CANCELLED: Proposta cancelada

  // Blockchain data
  txHash      String @db.VarChar(66)
  blockNumber Int

  // Timestamps
  createdAt DateTime  @default(now())
  startedAt DateTime? // Quando virou referendum

  // Relação com referendum (se virou referendum)
  referendum GovernanceReferendum?

  @@index([proposalIndex])
  @@index([proposalHash])
  @@index([status])
  @@index([createdAt(sort: Desc)])
  @@map("governance_democracy_proposals")
}

// Tabela para salvar referendos com metadata persistente
model GovernanceReferendum {
  id Int @id @default(autoincrement())

  // Dados do referendum on-chain
  refIndex  Int    @unique
  threshold String @db.VarChar(50) // VoteThreshold (SimpleMajority, SuperMajorityApprove, etc)

  // Metadata copiado da proposta original
  title       String  @db.VarChar(255)
  description String  @db.Text
  proposer    String? @db.VarChar(66)

  // Linkagem com proposta original
  proposalId   Int?    @unique
  proposalHash String? @db.VarChar(66)
  preimageHash String? @db.VarChar(66)

  // Status
  status String @default("ONGOING") @db.VarChar(50)
  // ONGOING: Referendum ativo, aceitando votos
  // APPROVED: Passou (será executado)
  // REJECTED: Não passou
  // EXECUTED: Foi executado

  // Blockchain data
  startTxHash      String  @db.VarChar(66) // Tx do evento Started
  startBlockNumber Int // Bloco do evento Started
  endTxHash        String? @db.VarChar(66) // Tx do resultado final
  endBlockNumber   Int? // Bloco do resultado final

  // Timestamps
  createdAt  DateTime  @default(now()) // Quando Started
  endedAt    DateTime? // Quando Passed/NotPassed
  executedAt DateTime? // Quando Executed

  // Relação com proposta original (FK opcional)
  proposal GovernanceDemocracyProposal? @relation(fields: [proposalId], references: [id])

  @@index([refIndex])
  @@index([status])
  @@index([proposalHash])
  @@index([createdAt(sort: Desc)])
  @@map("governance_referendums")
}

// ============================================================================
// Blockchain Commerce Sync Models (for blockchain-sync.worker)
// ============================================================================

model BlockchainOrder {
  id          Int      @id @default(autoincrement())
  orderId     Int      @unique // On-chain order ID
  buyer       String   @db.VarChar(66)
  seller      String   @db.VarChar(66)
  marketplace Int
  totalAmount String   @db.VarChar(100) // Stored as string to preserve precision
  status      String   @default("CREATED") @db.VarChar(50) // CREATED, PROOF_SUBMITTED, DISPUTED, COMPLETED
  txHash      String   @db.VarChar(66)
  blockNumber Int
  createdAt   DateTime @default(now())

  @@index([orderId])
  @@index([buyer])
  @@index([seller])
  @@index([status])
  @@index([createdAt])
  @@map("blockchain_orders")
}

model DeliveryProof {
  id          Int      @id @default(autoincrement())
  orderId     Int
  proofCid    String   @db.VarChar(100) // IPFS CID
  attestor    String   @db.VarChar(66) // Courier who submitted proof
  txHash      String   @db.VarChar(66)
  blockNumber Int
  submittedAt DateTime @default(now())

  @@unique([orderId, proofCid])
  @@index([orderId])
  @@index([attestor])
  @@index([submittedAt])
  @@map("delivery_proofs")
}

model BlockchainDispute {
  id          Int      @id @default(autoincrement())
  disputeId   Int      @unique // On-chain dispute ID
  orderId     Int
  plaintiff   String   @db.VarChar(66)
  defendant   String   @db.VarChar(66)
  status      String   @default("OPENED") @db.VarChar(50) // OPENED, VOTING, RESOLVED
  txHash      String   @db.VarChar(66)
  blockNumber Int
  createdAt   DateTime @default(now())

  @@index([disputeId])
  @@index([orderId])
  @@index([plaintiff])
  @@index([defendant])
  @@index([status])
  @@index([createdAt])
  @@map("blockchain_disputes")
}

// ==================== BAZARI REWARDS (BLOCKCHAIN GAMIFICATION) ====================

model Mission {
  id            String   @id @default(cuid())
  missionId     Int      @unique // ID from blockchain
  title         String
  description   String   @db.Text
  missionType   String // FirstPurchase, CompleteNOrders, SpendAmount, ReferFriend, DailyLogin
  rewardAmount  String // ZARI amount (smallest unit, 12 decimals)
  requiredCount Int // Target value to complete
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())

  userProgress UserMissionProgress[]

  @@index([missionId])
  @@index([missionType])
  @@index([isActive])
  @@map("missions")
}

model UserMissionProgress {
  id           String    @id @default(cuid())
  userId       String
  missionId    Int
  currentCount Int       @default(0)
  isCompleted  Boolean   @default(false)
  isClaimed    Boolean   @default(false)
  completedAt  DateTime?
  claimedAt    DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  user    Profile @relation(fields: [userId], references: [id], onDelete: Cascade)
  mission Mission @relation(fields: [missionId], references: [missionId], onDelete: Cascade)

  @@unique([userId, missionId])
  @@index([userId])
  @@index([missionId])
  @@index([isCompleted])
  @@index([isClaimed])
  @@map("user_mission_progress")
}

model CashbackGrant {
  id             String   @id @default(cuid())
  userId         String
  orderAmount    String // BZR amount spent (smallest unit)
  cashbackAmount String // ZARI amount granted (smallest unit, 12 decimals)
  orderId        String? // Optional reference to order
  grantedAt      DateTime @default(now())

  user Profile @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([grantedAt])
  @@index([orderId])
  @@map("cashback_grants")
}

// ==================== BAZARI VR MODELS ====================

// VR Session tracking (multiplayer)
model VRSession {
  id        String    @id @default(cuid())
  userId    String
  worldZone String // "plaza", "avenue", "auditorium", "building"
  enteredAt DateTime  @default(now())
  leftAt    DateTime?

  @@index([userId])
  @@index([worldZone])
  @@index([enteredAt])
  @@map("vr_sessions")
}

// Auditorium events
model AuditoriumEvent {
  id          String   @id @default(cuid())
  title       String
  description String?  @db.Text
  startAt     DateTime
  endAt       DateTime
  hostUserId  String
  maxSeats    Int      @default(50)
  status      String   @default("scheduled") // "scheduled", "live", "ended", "cancelled"
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([startAt])
  @@index([status])
  @@index([hostUserId])
  @@map("auditorium_events")
}

// Land NFT (terrenos virtuais)
model Land {
  id String @id @default(cuid())

  // Endereçamento único
  address   String @unique // "AVP-N-042", "PLC-C-001", etc.
  zone      String // "AVP", "PLC", "BGT", "BTH", "PCL", "GFD"
  sector    String // "N", "E", "S", "W", "A", "B", "C", "D"
  lotNumber Int

  // Posicionamento 3D
  positionX Float
  positionY Float
  positionZ Float
  rotation  Float @default(0) // Rotação em radianos

  // Dimensões
  width Float // Largura em metros
  depth Float // Profundidade em metros
  area  Float // width * depth (m²)

  // Classificação
  size String // "micro", "small", "medium", "large", "mega"
  tier String // "S", "A", "B", "C", "D"

  // NFT blockchain
  nftId       String? @unique // Token ID on-chain
  nftContract String? // Endereço do contrato ERC-721

  // Propriedade
  ownerId String? // User.id do proprietário

  // Aluguel
  isForRent   Boolean   @default(false)
  rentPrice   Decimal?  @db.Decimal(20, 12) // Preço em BZR por mês
  tenantId    String? // User.id do inquilino
  rentStartAt DateTime?
  rentEndsAt  DateTime?

  // Loja construída (relação 1:1)
  storeId String?        @unique // SellerProfile.id
  store   SellerProfile? @relation(fields: [storeId], references: [id])

  // Metadados
  isAvailable Boolean @default(true) // Se está à venda
  basePrice   Decimal @db.Decimal(20, 12) // Preço base de compra em BZR

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([zone, sector, lotNumber])
  @@index([ownerId])
  @@index([tenantId])
  @@index([isAvailable])
  @@index([address])
  @@map("lands")
}

// ========================================
// VR Integration Models
// ========================================

model VRToken {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  token     String   @unique
  used      Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([token, used])
  @@index([userId, createdAt])
}

// ========================================
// BazariOS App Store - Third Party Apps
// ========================================

model ThirdPartyApp {
  id String @id @default(cuid())

  // Identificação
  appId String @unique // ex: "com.dev.myapp"
  name  String
  slug  String @unique

  // Desenvolvedor
  developerId String
  developer   User   @relation("DeveloperApps", fields: [developerId], references: [id])

  // Metadados
  description     String
  longDescription String?
  category        String
  tags            String[]
  icon            String
  color           String
  screenshots     String[]

  // Técnico
  currentVersion String
  sdkVersion     String
  bundleUrl      String // URL do bundle (IPFS ou CDN)
  bundleHash     String // Hash para verificação

  // Permissões
  permissions Json // Array de { id, reason, optional }

  // Status
  status   AppStatus @default(DRAFT)
  featured Boolean   @default(false)

  // Métricas
  installCount Int    @default(0)
  rating       Float?
  ratingCount  Int    @default(0)

  // Monetização
  monetizationType MonetizationType @default(FREE)
  price            Decimal?         @db.Decimal(18, 8)
  currency         String           @default("BZR")

  // Revenue
  totalRevenue     Decimal @default(0) @db.Decimal(18, 8)
  developerRevenue Decimal @default(0) @db.Decimal(18, 8)
  platformRevenue  Decimal @default(0) @db.Decimal(18, 8)

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  publishedAt DateTime?

  // Review fields (TODO: integrar com governance/conselho)
  submittedAt DateTime?
  reviewedAt  DateTime?
  reviewerId  String?
  reviewNotes String?

  // Relações
  versions       AppVersion[]
  reviews        AppReview[]
  submissions    AppSubmission[]
  inAppPurchases InAppPurchase[]
  purchases      AppPurchase[]   @relation("AppPurchases")

  @@index([developerId])
  @@index([category])
  @@index([status])
  @@index([monetizationType])
}

model AppVersion {
  id    String        @id @default(cuid())
  appId String
  app   ThirdPartyApp @relation(fields: [appId], references: [id], onDelete: Cascade)

  version    String
  changelog  String?
  bundleUrl  String
  bundleHash String

  status VersionStatus @default(PENDING)

  createdAt   DateTime  @default(now())
  reviewedAt  DateTime?
  reviewedBy  String?
  reviewNotes String?

  @@unique([appId, version])
  @@index([appId])
}

model AppSubmission {
  id    String        @id @default(cuid())
  appId String
  app   ThirdPartyApp @relation(fields: [appId], references: [id], onDelete: Cascade)

  version String
  notes   String?

  status SubmissionStatus @default(PENDING)

  submittedAt DateTime  @default(now())
  reviewedAt  DateTime?
  reviewedBy  String?
  reviewNotes String?

  @@index([appId])
  @@index([status])
}

model AppReview {
  id    String        @id @default(cuid())
  appId String
  app   ThirdPartyApp @relation(fields: [appId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation("AppReviews", fields: [userId], references: [id])

  rating  Int // 1-5
  comment String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([appId, userId])
  @@index([appId])
}

enum AppStatus {
  DRAFT
  PENDING         // Aguardando início do review
  PENDING_REVIEW  // Legacy - alias for PENDING
  IN_REVIEW       // Em análise por reviewer
  APPROVED
  PUBLISHED
  REJECTED
  SUSPENDED
  DEPRECATED
  UNPUBLISHED     // Removido da loja mas não deletado
}

enum VersionStatus {
  PENDING
  APPROVED
  REJECTED
}

enum SubmissionStatus {
  PENDING
  IN_REVIEW
  APPROVED
  REJECTED
  CANCELLED
}

enum MonetizationType {
  FREE
  PAID
  FREEMIUM
  SUBSCRIPTION
}

enum PurchaseType {
  CONSUMABLE // Pode comprar múltiplas vezes
  NON_CONSUMABLE // Compra única permanente
  SUBSCRIPTION // Recorrente
}

enum PaymentStatus {
  PENDING
  CONFIRMED
  FAILED
  REFUNDED
}

// ========================================
// BazariOS App Store - In-App Purchases
// ========================================

model InAppPurchase {
  id    String        @id @default(cuid())
  appId String
  app   ThirdPartyApp @relation(fields: [appId], references: [id], onDelete: Cascade)

  productId   String // ID único do produto no app
  name        String
  description String?
  price       Decimal      @db.Decimal(18, 8)
  currency    String       @default("BZR")
  type        PurchaseType

  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  purchases AppPurchase[] @relation("IAPPurchases")

  @@unique([appId, productId])
  @@index([appId])
}

model AppPurchase {
  id String @id @default(cuid())

  userId String
  user   User   @relation("UserAppPurchases", fields: [userId], references: [id])

  appId String
  app   ThirdPartyApp @relation("AppPurchases", fields: [appId], references: [id])

  inAppPurchaseId String?
  inAppPurchase   InAppPurchase? @relation("IAPPurchases", fields: [inAppPurchaseId], references: [id])

  type     String // "app" | "iap"
  amount   Decimal @db.Decimal(18, 8)
  currency String  @default("BZR")

  developerShare Decimal @db.Decimal(18, 8)
  platformShare  Decimal @db.Decimal(18, 8)

  txHash String? // Hash da transação blockchain
  status PaymentStatus @default(PENDING)

  createdAt   DateTime  @default(now())
  confirmedAt DateTime?

  // Refund fields
  refundedAt   DateTime?
  refundReason String?
  refundTxHash String?

  @@index([userId])
  @@index([appId])
  @@index([status])
}

// ========================================
// BazariOS Plugin System (Low-Code)
// ========================================

enum PluginCategory {
  ENGAGEMENT // Fidelidade, Gamificação
  MARKETING // Cupons, Promoções
  OPERATIONS // Delivery, Estoque
  PAYMENTS // Cashback, Parcelamento
  ANALYTICS // Relatórios, Insights
  COMMUNICATION // Chat, Notificações
}

enum PluginPricing {
  FREE
  PAID
  FREEMIUM
  USAGE_BASED
}

// Definição do plugin (template)
model PluginDefinition {
  id          String         @id @default(cuid())
  slug        String         @unique // "loyalty-program"
  name        String // "Programa de Fidelidade"
  description String         @db.Text
  version     String         @default("1.0.0")
  category    PluginCategory

  // Pricing
  pricingType  PluginPricing @default(FREE)
  priceMonthly Decimal?      @db.Decimal(18, 12)
  pricingTiers Json? // { "basic": 0, "pro": 10 }

  // Schema de configuração (JSON Schema)
  configSchema  Json // Define campos configuráveis
  defaultConfig Json // Valores padrão

  // Componentes que o plugin usa
  components Json // { "storePage": "LoyaltyWidget", ... }

  // Hooks (eventos que disparam ações)
  hooks Json? // { "onPurchase": "addPoints", ... }

  // Smart contract associado (opcional)
  contractAddress String?
  contractAbi     Json?

  // Metadata
  iconUrl       String?
  bannerUrl     String?
  developerName String  @default("Bazari")
  isOfficial    Boolean @default(true)
  isActive      Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  instances PluginInstance[]

  @@index([category])
  @@index([isActive])
  @@index([slug])
}

// Instância do plugin (configuração do lojista)
model PluginInstance {
  id String @id @default(cuid())

  pluginId String
  plugin   PluginDefinition @relation(fields: [pluginId], references: [id])

  sellerId String
  seller   SellerProfile @relation(fields: [sellerId], references: [id])

  storeId String?

  // Estado
  enabled Boolean @default(true)

  // Configuração customizada pelo lojista
  config   Json // Valores específicos do lojista
  branding Json? // Cores, logo, etc

  // Dados runtime
  stats Json? // Estatísticas de uso

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relação com dados de fidelidade
  loyaltyPoints    LoyaltyPoints[]
  pendingCashbacks PendingCashback[]

  @@unique([pluginId, sellerId, storeId])
  @@index([sellerId])
  @@index([pluginId])
  @@index([enabled])
}

// Pontos de fidelidade por usuário/loja
model LoyaltyPoints {
  id String @id @default(cuid())

  instanceId String
  instance   PluginInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  userId      String // User.id ou Profile.id
  points      Int    @default(0)
  totalEarned Int    @default(0) // Total acumulado (histórico)
  tier        String @default("bronze") // bronze, silver, gold, platinum

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([instanceId, userId])
  @@index([instanceId])
  @@index([userId])
  @@index([tier])
}

// Cashback pendente
model PendingCashback {
  id String @id @default(cuid())

  pluginInstanceId String
  pluginInstance   PluginInstance @relation(fields: [pluginInstanceId], references: [id], onDelete: Cascade)

  orderId String
  userId  String
  amount  Decimal @db.Decimal(20, 12) // Valor em BZR (planck)

  scheduledFor DateTime // Quando será creditado
  status       CashbackStatus @default(PENDING)

  creditedAt DateTime?
  txHash     String? // Hash da transação quando creditado

  createdAt DateTime @default(now())

  @@index([pluginInstanceId])
  @@index([userId])
  @@index([orderId])
  @@index([status])
  @@index([scheduledFor])
}

enum CashbackStatus {
  PENDING
  CREDITED
  CANCELLED
  FAILED
}

// ============================================
// DEVELOPER APP REGISTRY (SDK Security)
// ============================================

// Status de um app de desenvolvedor
enum DeveloperAppStatus {
  PENDING // Aguardando aprovação
  APPROVED // Aprovado e ativo
  SUSPENDED // Suspenso temporariamente
  REJECTED // Rejeitado
}

// App registrado por um desenvolvedor
model DeveloperApp {
  id String @id @default(cuid())

  // Relação com desenvolvedor
  developerId String
  developer   Profile @relation("DeveloperApps", fields: [developerId], references: [id], onDelete: Cascade)

  // Informações básicas
  name        String
  slug        String  @unique // URL-friendly identifier
  description String?
  websiteUrl  String?

  // Credenciais de API
  apiKey        String  @unique // baz_app_xxxxx (produção) ou baz_test_xxxxx (sandbox)
  secretKeyHash String? // Hash da secret key para HMAC (nunca armazena plain text)

  // Segurança
  allowedOrigins String[] // Origens permitidas para postMessage
  permissions    String[] // Permissões concedidas (ex: wallet:read, wallet:transfer)

  // Status e moderação
  status      DeveloperAppStatus @default(PENDING)
  reviewNotes String? // Notas do revisor
  reviewedAt  DateTime?
  reviewedBy  String? // Profile ID do admin que revisou

  // Rate limiting customizado (opcional)
  rateLimitCapacity   Int? // Capacidade do bucket (default: 100)
  rateLimitRefillRate Int? // Tokens por segundo (default: 10)

  // Estatísticas
  totalRequests BigInt    @default(0)
  lastRequestAt DateTime?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Logs de uso
  usageLogs DeveloperAppUsageLog[]

  @@index([developerId])
  @@index([status])
  @@index([apiKey])
}

// Log de uso de apps (para analytics e auditoria)
model DeveloperAppUsageLog {
  id String @id @default(cuid())

  appId String
  app   DeveloperApp @relation(fields: [appId], references: [id], onDelete: Cascade)

  // Detalhes da requisição
  messageType String // Tipo de mensagem (ex: wallet:getBalance)
  success     Boolean
  errorCode   String? // Código de erro se falhou

  // Metadados
  userAgent String?
  origin    String? // Origem da requisição

  // Performance
  responseTimeMs Int? // Tempo de resposta em ms

  createdAt DateTime @default(now())

  @@index([appId])
  @@index([messageType])
  @@index([createdAt])
  @@index([success])
}
