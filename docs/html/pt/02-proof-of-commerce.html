<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Proof of Commerce - EspecificaÃ§Ã£o TÃ©cnica - Bazari Documentation">
  <title>Proof of Commerce - EspecificaÃ§Ã£o TÃ©cnica | Bazari Docs</title>
  <link rel="stylesheet" href="../assets/style.v2.css">
  <link rel="stylesheet" href="../assets/prism.v2.css">
</head>
<body>
  <div class="doc-container">
    <!-- Header -->
    <header class="doc-header">
      <h1><span class="logo">ğŸª</span> Bazari Docs</h1>
      <div class="doc-controls">
        <nav class="lang-switcher">
          <button data-lang="pt" class='active'>ğŸ‡§ğŸ‡· PT</button>
          <button data-lang="en" >ğŸ‡ºğŸ‡¸ EN</button>
          </nav>
        <button class="theme-toggle">ğŸŒ™</button>
      </div>
    </header>

    <!-- Sidebar -->
    <aside class="doc-sidebar">
      <h2 id="documentacao">ğŸ“š DocumentaÃ§Ã£o</h2>
      <nav class="doc-nav">
        <ul>
          <li><a href="index.html">ğŸ  InÃ­cio</a></li>
          <li><a href="01-visao-geral.html" >01. VisÃ£o Geral e Contexto</a></li>
          <li><a href="02-proof-of-commerce.html" class="active">02. Proof of Commerce - EspecificaÃ§Ã£o TÃ©cnica</a></li>
          <li><a href="03-dores-mercado.html" >03. Dores do Mercado e SoluÃ§Ãµes Bazari</a></li>
          <li><a href="04-modulos-ecossistema.html" >04. MÃ³dulos do Ecossistema Bazari</a></li>
          <li><a href="05-arquitetura.html" >05. Arquitetura e ImplementaÃ§Ã£o TÃ©cnica</a></li>
          <li><a href="06-roadmap.html" >06. Roadmap e EvoluÃ§Ã£o Futura</a></li>
        </ul>
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="doc-main">
      <h2 id="indice">Ãndice</h2>
<p>1. <a href="#1-visao-geral-do-protocolo">VisÃ£o Geral do Protocolo</a></p>
<p>2. <a href="#2-problemas-de-fraude-resolvidos">Problemas de Fraude Resolvidos</a></p>
<p>3. <a href="#3-entidades-e-papeis">Entidades e PapÃ©is</a></p>
<p>4. <a href="#4-primitivos-do-protocolo">Primitivos do Protocolo</a></p>
<p>5. <a href="#5-provas-criptograficas-e-ancoras">Provas CriptogrÃ¡ficas e Ã‚ncoras</a></p>
<p>6. <a href="#6-maquina-de-estados">MÃ¡quina de Estados</a></p>
<p>7. <a href="#7-fluxos-essenciais">Fluxos Essenciais</a></p>
<p>8. <a href="#8-sistema-de-afiliados">Sistema de Afiliados</a></p>
<p>9. <a href="#9-sistema-de-reputacao">Sistema de ReputaÃ§Ã£o</a></p>
<p>10. <a href="#10-economia-e-seguranca">Economia e SeguranÃ§a</a></p>
<p>11. <a href="#11-invariantes-de-protocolo">Invariantes de Protocolo</a></p>
<p>12. <a href="#12-exemplos-praticos-detalhados">Exemplos PrÃ¡ticos Detalhados</a></p>
<p>13. <a href="#13-hardening-do-modulo-de-disputas">Hardening do MÃ³dulo de Disputas</a></p>
<p>---</p>
<h2 id="1-visao-geral-do-protocolo">1. VisÃ£o Geral do Protocolo</h2>
<h3 id="11-a-ideia-central">1.1 A Ideia Central</h3>
<p>O <strong>Proof of Commerce</strong> substitui confianÃ§a por provas matemÃ¡ticas. Cada pedido no marketplace Bazari cria um <strong>micro-consenso</strong> entre as partes envolvidas:</p>
<ul><li><strong>Comprador</strong> (Buyer)</li>
<li><strong>Lojista</strong> (Seller)</li>
<li><strong>Entregador</strong> (Courier)</li>
<li><strong>Afiliados</strong> (Affiliates) - opcional</li>
<pre><code class="language-">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
<p>â”‚          PEDIDO = MICRO-CONSENSO                    â”‚</p>
<p>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</p>
<p>â”‚                                                     â”‚</p>
<p>â”‚  Buyer cria Order + deposita BZR em Escrow         â”‚</p>
<p>â”‚         â†“                                           â”‚</p>
<p>â”‚  Seller aceita                                      â”‚</p>
<p>â”‚         â†“                                           â”‚</p>
<p>â”‚  Courier assume (deposita stake)                    â”‚</p>
<p>â”‚         â†“                                           â”‚</p>
<p>â”‚  HandoffProof: Seller + Courier co-assinam         â”‚</p>
<p>â”‚         â†“                                           â”‚</p>
<p>â”‚  DeliveryProof: Courier + Buyer co-assinam         â”‚</p>
<p>â”‚         â†“                                           â”‚</p>
<p>â”‚  PoCEngine valida QUÃ“RUM                            â”‚</p>
<p>â”‚         â†“                                           â”‚</p>
<p>â”‚  Split automÃ¡tico:                                  â”‚</p>
<p>â”‚    â€¢ Seller recebe preÃ§o do produto                 â”‚</p>
<p>â”‚    â€¢ Courier recebe frete                           â”‚</p>
<p>â”‚    â€¢ Affiliates recebem comissÃµes                   â”‚</p>
<p>â”‚    â€¢ DAO recebe taxa                                â”‚</p>
<p>â”‚         â†“                                           â”‚</p>
<p>â”‚  ReputaÃ§Ãµes atualizadas                             â”‚</p>
<p>â”‚                                                     â”‚</p>
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
<h3 id="12-quorum-minimo">1.2 QuÃ³rum MÃ­nimo</h3>
<p>O protocolo exige <strong>atestados co-assinados</strong> nas etapas crÃ­ticas:</p>
<p>| Etapa | SignatÃ¡rios Requeridos | Prova Gerada |</p>
<p>|-------|------------------------|--------------|</p>
| <code>ORDER_CREATED</code> | Buyer (implÃ­cito pelo escrow) | TransaÃ§Ã£o on-chain |
| <code>HANDOFF</code> | Seller + Courier | HandoffProof |
| <code>DELIVERED</code> | Courier + Buyer | DeliveryProof |
<p><strong>Regra Fundamental</strong>: Sem o quÃ³rum mÃ­nimo de atestados vÃ¡lidos, nÃ£o hÃ¡ liquidaÃ§Ã£o. O escrow permanece bloqueado ou o caso vai para disputa.</p>
<h3 id="13-descentralizacao-radical">1.3 DescentralizaÃ§Ã£o Radical</h3>
<li><strong>NÃ£o hÃ¡ autoridade central</strong> para aprovar/negar pedidos</li>
<li><strong>NÃ£o hÃ¡ custÃ³dia de fundos</strong> por empresa (apenas smart contracts)</li>
<li><strong>NÃ£o hÃ¡ decisÃµes arbitrÃ¡rias</strong> â€” apenas execuÃ§Ã£o determinÃ­stica de regras</li>
<li><strong>Disputas</strong> sÃ£o resolvidas por jÃºri descentralizado (jurors com stake) selecionado por aleatoriedade verificÃ¡vel (VRF)</li>
<p>---</p>
<h2 id="2-problemas-de-fraude-resolvidos">2. Problemas de Fraude Resolvidos</h2>
<p>O PoC foi projetado para neutralizar <strong>todos os vetores comuns de fraude</strong> em marketplaces. Abaixo, cada fraude Ã© mapeada com:</p>
<li>CenÃ¡rio real</li>
<li>Defesa do PoC</li>
<li>Mecanismo tÃ©cnico</li>
<li>Efeito econÃ´mico</li>
<p>---</p>
<h3 id="21-fraude-produto-nao-recebido-buyer-fraud">2.1 Fraude: "Produto NÃ£o Recebido" (Buyer Fraud)</h3>
<h4 id="cenario-real">CenÃ¡rio Real</h4>
<p>Comprador recebe o produto mas afirma que nÃ£o chegou, tentando reembolso ou chargeback social.</p>
<h4 id="defesa-poc">Defesa PoC</h4>
<strong>Prova NecessÃ¡ria</strong>: <code>DeliveryProof</code> co-assinado por <strong>Courier + Buyer</strong>
<pre><code class="language-json">{
<p>  "order_id": "0x1a2b3c...",</p>
<p>  "step": "DELIVERED",</p>
<p>  "timestamp": "2025-10-28T14:32:00Z",</p>
<p>  "geo": {"lat": -23.5505, "lon": -46.6333, "accuracy": 10},</p>
<p>  "media_cid": "QmXyz...",  // IPFS: foto da entrega</p>
<p>  "signature_method": "photo_capture_with_recipient",</p>
<p>  "observation": "Entregue ao morador, assinado digitalmente",</p>
<p>  "signers": [</p>
<p>    {"account_id": "5Courier...", "signature": "0xabc..."},</p>
<p>    {"account_id": "5Buyer...", "signature": "0xdef..."}</p>
<p>  ]</p>
}</code></pre>
<strong>Ã‚ncora On-Chain</strong>: Apenas o <code>payload_hash</code> (Blake2-256 do JSON acima) Ã© gravado na blockchain.
<p><strong>Mecanismo</strong>:</p>
<p>1. Sem a assinatura do Buyer, o pedido nÃ£o finaliza automaticamente</p>
<p>2. Se o Buyer assina no momento da entrega, qualquer alegaÃ§Ã£o posterior de "nÃ£o recebimento" Ã© contraprova fraca</p>
<p>3. JÃºri pode comparar timestamp, geo e mÃ­dia em caso de disputa</p>
<h4 id="efeito-economico">Efeito EconÃ´mico</h4>
<li><strong>Chargeback social eliminado</strong>: Prova criptogrÃ¡fica > palavra contra palavra</li>
<li><strong>Custo de fraude</strong>: Se o Buyer abrir disputa infundada, perde reputaÃ§Ã£o e pode ter stake exigido em compras futuras</li>
<p>---</p>
<h3 id="22-fraude-entreguei-mas-cliente-nao-confirma-courierseller-fraud">2.2 Fraude: "Entreguei, Mas Cliente NÃ£o Confirma" (Courier/Seller Fraud)</h3>
<h4 id="cenario-real">CenÃ¡rio Real</h4>
<p>Lojista ou entregador alegam entrega sem comprovaÃ§Ã£o do destinatÃ¡rio, tentando liberar pagamento unilateralmente.</p>
<h4 id="defesa-poc">Defesa PoC</h4>
<strong>FinalizaÃ§Ã£o Requer</strong>: <code>DELIVERED = Courier + Buyer</code>
<p><strong>Mecanismo</strong>:</p>
<li>Sem co-assinatura do Buyer, o escrow <strong>nÃ£o Ã© liberado</strong></li>
<li>Se o Buyer estÃ¡ ausente e o Courier entrega a terceiro (ex.: porteiro), deve registrar:</li>
<p>  - Foto do recebedor</p>
<p>  - Assinatura digital ou captura do rosto</p>
<p>  - ObservaÃ§Ã£o no payload: "left with doorman - photo attached"</p>
<p>  - Isso ancora via hash</p>
<p><strong>ExceÃ§Ã£o</strong>: Timeout + evidÃªncia fotogrÃ¡fica pode acionar disputa automÃ¡tica para jÃºri avaliar</p>
<h4 id="efeito-economico">Efeito EconÃ´mico</h4>
<li><strong>LiberaÃ§Ã£o unilateral impedida</strong>: Courier nÃ£o pode "fingir entrega" sozinho</li>
<li><strong>Incentivo para boas prÃ¡ticas</strong>: Courier tem interesse em capturar provas robustas para evitar disputas</li>
<p>---</p>
<h3 id="23-fraude-produto-diferentedefeituoso-seller-quality-fraud">2.3 Fraude: "Produto Diferente/Defeituoso" (Seller Quality Fraud)</h3>
<h4 id="cenario-real">CenÃ¡rio Real</h4>
<li>Item trocado (enviou chinelo em vez de tÃªnis)</li>
<li>Lacre violado</li>
<li>Defeito oculto</li>
<h4 id="defesa-poc">Defesa PoC</h4>
<p><strong>Duas Provas Cruzadas</strong>:</p>
<p>1. <strong>HandoffProof</strong> (Seller + Courier) â€” captura <strong>estado do pacote na retirada</strong></p>
<p>   - Foto do lacre</p>
<p>   - NÃºmero de sÃ©rie visÃ­vel</p>
<p>   - Peso/dimensÃµes</p>
<p>2. <strong>DeliveryProof</strong> (Courier + Buyer) â€” captura <strong>estado no recebimento</strong></p>
<p>   - Foto do pacote recebido</p>
<p>   - CondiÃ§Ã£o do lacre</p>
<p>   - Assinatura de recebimento</p>
<p><strong>Mecanismo de AtribuiÃ§Ã£o de Responsabilidade</strong>:</p>
<pre><code class="language-">HandoffProof mostra: lacre INTACTO, produto correto
<p>DeliveryProof mostra: lacre VIOLADO, produto diferente</p>
<p>        â†“</p>
<p>Responsabilidade: COURIER (dano no trajeto)</p>
<p>        â†“</p>
<p>Slashing do stake do Courier</p>
<p>CompensaÃ§Ã£o ao Buyer</p>
Seller recebe pagamento</code></pre>
<pre><code class="language-">HandoffProof mostra: lacre VIOLADO
<p>        â†“</p>
<p>Responsabilidade: SELLER (produto jÃ¡ saiu errado)</p>
<p>        â†“</p>
<p>Escrow retorna ao Buyer</p>
Slashing de reputaÃ§Ã£o do Seller</code></pre>
<h4 id="efeito-economico">Efeito EconÃ´mico</h4>
<li><strong>Rastreabilidade completa</strong>: DivergÃªncias entre provas identificam exatamente onde ocorreu o problema</li>
<li><strong>ResponsabilizaÃ§Ã£o objetiva</strong>: JÃºri tem evidÃªncias timestamped e imutÃ¡veis</li>
<p>---</p>
<h3 id="24-fraude-golpe-do-intermediario-man-in-the-middle-social">2.4 Fraude: "Golpe do IntermediÃ¡rio" (Man-in-the-Middle Social)</h3>
<h4 id="cenario-real">CenÃ¡rio Real</h4>
<p>AlguÃ©m se passa por lojista ou entregador legÃ­timo e tenta capturar pagamento fora do app (ex.: "me pague por PIX que Ã© mais rÃ¡pido").</p>
<h4 id="defesa-poc">Defesa PoC</h4>
<p><strong>Pagamento Reconhecido APENAS se</strong>:</p>
<li>Escrow on-chain em BZR</li>
<li>Identidades dos papÃ©is sÃ£o contas verificadas on-chain</li>
<li>Split sÃ³ ocorre com atestados vÃ¡lidos com assinaturas das contas cadastradas</li>
<p><strong>Identidades Podem Ter</strong>:</p>
<li>DID (Decentralized Identifier)</li>
<li>Verifiable Credentials emitidos por comunidades (ex.: "Entregador verificado pela Cooperativa X")</li>
<li>ReputaÃ§Ã£o pÃºblica (PoC Score visÃ­vel)</li>
<h4 id="efeito-economico">Efeito EconÃ´mico</h4>
<li><strong>TransaÃ§Ãµes fora do protocolo nÃ£o liberam fundos</strong></li>
<li><strong>Golpista nÃ£o pode forjar assinaturas</strong> (chaves privadas das contas legÃ­timas)</li>
<li><strong>UsuÃ¡rios educados</strong>: "Pagamento sÃ³ vale se for pelo app"</li>
<p>---</p>
<h3 id="25-fraude-spam-de-afiliados-affiliate-inflation">2.5 Fraude: "Spam de Afiliados" (Affiliate Inflation)</h3>
<h4 id="cenario-real">CenÃ¡rio Real</h4>
<p>Cadeia artificial de compartilhamentos para inflar comissÃµes (ex.: 30 contas falsas em sÃ©rie para capturar mais % da comissÃ£o).</p>
<h4 id="defesa-poc">Defesa PoC</h4>
<p><strong>Mecanismo: Merkle Proof + DAG de Campanha</strong></p>
<p>1. Seller cria campanha com parÃ¢metros:</p>
<p>   - Taxa de comissÃ£o total (ex.: 5%)</p>
<p>   - Cap de hops (mÃ¡ximo 5 nÃ­veis)</p>
<p>   - Decay por nÃ­vel (ex.: 50% do anterior)</p>
<p>2. Cada compartilhamento gera nÃ³ no DAG; root do DAG Ã© publicado on-chain</p>
3. Order inclui <code>AffiliatePath</code> (Merkle proof do caminho completo)
4. <code>finalize()</code> valida:
   <pre><code class="language-">   - Merkle proof Ã© vÃ¡lido contra root publicado?
<p>   - Hops <= cap configurado?</p>
<p>   - Cada afiliado tem stake/reputaÃ§Ã£o mÃ­nima?</p>
<p>   - NÃ£o hÃ¡ loops (mesmo account_id repetido)?</p>
   ``<code>
<p>5. Se vÃ¡lido, split percorre o caminho e distribui comissÃµes com decay</p>
<h4 id="efeito-economico">Efeito EconÃ´mico</h4>
<li><strong>Somente caminhos prÃ©-anunciados</strong> (root publicado) recebem comissÃ£o</li>
<li><strong>Spam desincentivado</strong>: Exige stake mÃ­nimo por afiliado; fraude queima stake</li>
<li><strong>TransparÃªncia</strong>: Qualquer um pode auditar caminhos via Merkle proof</li>
<p>---</p>
<h3 id="26-fraude-conluio-entre-partes-collusion">2.6 Fraude: "Conluio Entre Partes" (Collusion)</h3>
<h4 id="cenario-real">CenÃ¡rio Real</h4>
<li>Buyer + Seller combinam criar pedidos falsos para drenar incentivos/airdrops</li>
<li>Buyer + Courier tentam lesar Seller (alegam nÃ£o recebimento sendo cÃºmplices)</li>
<h4 id="defesa-poc">Defesa PoC</h4>
<p><strong>Mecanismos Cruzados</strong>:</p>
<p>1. <strong>MÃºltiplas Co-Assinaturas Cruzadas</strong></p>
<p>   - Handoff: Seller + Courier</p>
<p>   - Delivery: Courier + Buyer</p>
<p>   - Nenhuma dupla pode finalizar sozinha</p>
<p>2. <strong>Stake & Slashing</strong></p>
<p>   - Courier deposita stake (ex.: 10-30% do valor do pedido)</p>
<p>   - Seller pode ter stake opcional para alto valor</p>
<p>   - Fraude comprovada = perda de stake</p>
<p>3. <strong>ReputaÃ§Ã£o por Papel</strong></p>
<p>   - SellerScore, CourierScore, BuyerScore sÃ£o independentes</p>
<p>   - PadrÃµes suspeitos (mesmas contas sempre trabalhando juntas + alto Ã­ndice de disputas) podem acionar auditoria</p>
<p>4. <strong>Amostragem AleatÃ³ria (Fase 2)</strong></p>
<p>   - Pedidos de alto valor podem ter auditoria por jurors mesmo sem disputa aberta</p>
<p>   - SeleÃ§Ã£o por VRF (imprevisÃ­vel)</p>
<h4 id="efeito-economico">Efeito EconÃ´mico</h4>
<li><strong>Custo de fraudar > ganho esperado</strong></li>
<p>   - Stake perdido + reputaÃ§Ã£o destruÃ­da + ban temporÃ¡rio</p>
<li><strong>Fraudes recorrentes</strong>:</li>
<p>   - Aumento progressivo de stake exigido</p>
<p>   - LimitaÃ§Ã£o de valor mÃ¡ximo por pedido para contas de baixa reputaÃ§Ã£o</p>
<p>---</p>
<h2 id="3-entidades-e-papeis">3. Entidades e PapÃ©is</h2>
<h3 id="31-participantes-principais">3.1 Participantes Principais</h3>
<p>| Papel | DescriÃ§Ã£o | Responsabilidades | Incentivos |</p>
<p>|-------|-----------|-------------------|------------|</p>
<p>| <strong>Buyer</strong> | Comprador final | â€¢ Criar Order<br>â€¢ Depositar escrow<br>â€¢ Co-assinar DeliveryProof | â€¢ Receber produto<br>â€¢ ReputaÃ§Ã£o para compras futuras |</p>
<p>| <strong>Seller</strong> | Comerciante/Lojista | â€¢ Aceitar Order<br>â€¢ Co-assinar HandoffProof<br>â€¢ Entregar produto ao Courier | â€¢ Receber pagamento instantÃ¢neo<br>â€¢ Construir reputaÃ§Ã£o |</p>
<p>| <strong>Courier</strong> | Entregador | â€¢ Depositar stake<br>â€¢ Co-assinar Handoff e Delivery<br>â€¢ Transportar produto | â€¢ Receber frete<br>â€¢ Construir PoC Score<br>â€¢ Stake devolvido |</p>
<p>| <strong>Affiliate</strong> | Indicador/Influencer | â€¢ Compartilhar produto<br>â€¢ Gerar conversÃµes | â€¢ ComissÃ£o por venda<br>â€¢ ReputaÃ§Ã£o de conversÃ£o |</p>
<h3 id="32-entidades-de-governanca">3.2 Entidades de GovernanÃ§a</h3>
<p>| Papel | FunÃ§Ã£o | SeleÃ§Ã£o |</p>
<p>|-------|--------|---------|</p>
<p>| <strong>Juror</strong> | Resolve disputas | VRF (aleatÃ³rio) entre stakers |</p>
<p>| <strong>Arbiter</strong> | Mesmo que Juror | (termos intercambiÃ¡veis) |</p>
<p>| <strong>BazariDAO</strong> | Governa parÃ¢metros do protocolo | Token holders (BZR) |</p>
<p><strong>Importante</strong>: DAO <strong>nÃ£o decide pedidos individuais</strong>. Apenas define:</p>
<li>% de taxas</li>
<li>Timeouts</li>
<li>Stakes mÃ­nimos</li>
<li>Destinos de fundos (Tesouro, incentivos)</li>
<p>---</p>
<h2 id="4-primitivos-do-protocolo">4. Primitivos do Protocolo</h2>
<h3 id="41-pallets-nucleo-fase-1">4.1 Pallets NÃºcleo (Fase 1)</h3>
<p>O protocolo Ã© implementado como mÃ³dulos (pallets) em Substrate:</p>
<h4></code>pallet-order<code></h4>
<li><strong>FunÃ§Ã£o</strong>: Gerencia ciclo de vida do pedido</li>
<li><strong>Storage</strong>:</li>
  - </code>Orders<OrderId, OrderData><code>: estado atual, partes envolvidas, valores
  - </code>OrderHistory<OrderId, Vec<StateTransition>><code>: log de mudanÃ§as
<li><strong>Extrinsics</strong>:</li>
  - </code>create_order(product, quantity, price, escrow_amount)<code>
  - </code>accept_order(order_id)<code>
  - </code>cancel_order(order_id, reason)<code>
<h4></code>pallet-escrow<code></h4>
<li><strong>FunÃ§Ã£o</strong>: Guarda BZR atÃ© conclusÃ£o do pedido</li>
<li><strong>Storage</strong>:</li>
  - </code>Locks<OrderId, Balance><code>: fundos bloqueados
  - </code>Releases<OrderId, Vec<(AccountId, Balance)>><code>: destinatÃ¡rios pendentes
<li><strong>Extrinsics</strong>:</li>
  - </code>deposit(order_id, amount)<code> â€” Buyer bloqueia fundos
  - </code>release(order_id)<code> â€” split automÃ¡tico apÃ³s finalize
  - </code>slash(order_id, account_id, amount)<code> â€” penalidade
<h4></code>pallet-attestation<code></h4>
<li><strong>FunÃ§Ã£o</strong>: Ancora provas (hashes) e valida signatÃ¡rios</li>
<li><strong>Storage</strong>:</li>
  - </code>Attestations<OrderId, Step, AttestationData><code>
    </code>`<code>rust
<p>    struct AttestationData {</p>
<p>        payload_hash: H256,</p>
<p>        signers: Vec<(AccountId, Signature)>,</p>
<p>        timestamp: BlockNumber,</p>
<p>        metadata: BoundedVec<u8>  // opcional: geo, IPFS CIDs</p>
<p>    }</p>
    </code>`<code>
<li><strong>Extrinsics</strong>:</li>
  - </code>submit_attestation(order_id, step, payload_hash, signatures)<code>
<h4></code>pallet-fulfillment<code></h4>
<li><strong>FunÃ§Ã£o</strong>: Matching de Courier + gestÃ£o de stake</li>
<li><strong>Storage</strong>:</li>
  - </code>Couriers<AccountId, CourierProfile><code>
  - </code>CourierStakes<OrderId, (AccountId, Balance)><code>
  - </code>LogisticStatus<OrderId, FulfillmentState><code>
<li><strong>Extrinsics</strong>:</li>
  - </code>apply_as_courier(order_id)<code>
  - </code>assign_courier(order_id, courier_account)<code> â€” Seller escolhe
  - </code>deposit_stake(order_id, amount)<code>
<h4></code>pallet-affiliate<code></h4>
<li><strong>FunÃ§Ã£o</strong>: DAG de comissÃµes + Merkle proofs</li>
<li><strong>Storage</strong>:</li>
  - </code>Campaigns<CampaignId, CampaignConfig><code>
  - </code>AffiliateRoots<CampaignId, MerkleRoot><code>
  - </code>AffiliatePayouts<OrderId, Vec<(AccountId, Balance)>><code>
<li><strong>Extrinsics</strong>:</li>
  - </code>create_campaign(rate, max_hops, decay)<code>
  - </code>submit_affiliate_path(order_id, merkle_proof)<code>
<h4></code>pallet-fee<code></h4>
<li><strong>FunÃ§Ã£o</strong>: CÃ¡lculo e destino de taxas</li>
<li><strong>Storage</strong>:</li>
  - </code>FeeConfig<code>: % para DAO, Tesouro, pools de incentivo
<li><strong>Extrinsics</strong>:</li>
  - </code>set_fee_config(new_config)<code> â€” DAO governance
<p>---</p>
<h3 id="42-pallets-de-robustez-fase-12">4.2 Pallets de Robustez (Fase 1.2)</h3>
<h4></code>pallet-reputation<code></h4>
<li><strong>FunÃ§Ã£o</strong>: PontuaÃ§Ã£o por papel com decay temporal</li>
<li><strong>Storage</strong>:</li>
  - </code>SellerScores<AccountId, Score><code>
  - </code>CourierScores<AccountId, Score><code>
  - </code>BuyerScores<AccountId, Score><code>
  - </code>AffiliateScores<AccountId, Score><code>
<li><strong>Inputs</strong>:</li>
<p>  - ConclusÃµes sem disputa (+)</p>
<p>  - SLAs cumpridos (+)</p>
<p>  - Disputas perdidas (-)</p>
<p>  - Slashes (---)</p>
<li><strong>Outputs</strong>:</li>
<p>  - Score 0-1000</p>
<p>  - Gates dinÃ¢micos (valor mÃ¡x. por pedido, stake exigido)</p>
<h4></code>pallet-dispute<code></h4>
<li><strong>FunÃ§Ã£o</strong>: GestÃ£o de disputas + jÃºri</li>
<li><strong>Storage</strong>:</li>
  - </code>Disputes<OrderId, DisputeData><code>
    </code>`<code>rust
<p>    struct DisputeData {</p>
<p>        opened_by: AccountId,</p>
<p>        opened_at: BlockNumber,</p>
<p>        jurors: Vec<AccountId>,</p>
<p>        votes: Vec<(AccountId, Vote, Justification)>,</p>
<p>        ruling: Option<Ruling>,</p>
<p>    }</p>
    </code>`<code>
  - </code>JurorPool<Vec<AccountId>><code>: stakers elegÃ­veis
<li><strong>Extrinsics</strong>:</li>
  - </code>open_dispute(order_id, reason, evidence_cids)<code>
  - </code>vote_on_dispute(order_id, vote, justification_hash)<code>
  - </code>finalize_dispute(order_id)<code> â€” aplica ruling
<p>---</p>
<h3 id="43-steps-canonicos">4.3 Steps CanÃ´nicos</h3>
</code></pre>rust
<p>enum OrderStep {</p>
<p>    ORDER_CREATED,</p>
<p>    ACCEPTED,</p>
<p>    HANDOFF_SELLER_TO_COURIER,</p>
<p>    IN_TRANSIT,</p>
<p>    DELIVERED_COURIER_TO_BUYER,</p>
<p>    FINALIZED,</p>
<p>    RETURNED,</p>
<p>    CANCELLED,</p>
<p>    DISPUTE_OPENED,</p>
<p>    RULING_APPLIED,</p>
<p>}</p>
<pre><code class="language-">
<p>---</p>
<h2 id="5-provas-criptograficas-e-ancoras">5. Provas CriptogrÃ¡ficas e Ã‚ncoras</h2>
<h3 id="51-recibos-co-assinados-off-chain">5.1 Recibos Co-Assinados (Off-Chain)</h3>
<p><strong>Formato JSON</strong> (exemplo HandoffProof):</p>
</code></pre>json
<p>{</p>
<p>  "order_id": "0x1a2b3c4d5e6f...",</p>
<p>  "step": "HANDOFF_SELLER_TO_COURIER",</p>
<p>  "timestamp": "2025-10-28T10:15:00Z",</p>
<p>  "geo": {</p>
<p>    "lat": -23.5505,</p>
<p>    "lon": -46.6333,</p>
<p>    "accuracy_meters": 5</p>
<p>  },</p>
<p>  "media": [</p>
<p>    {</p>
<p>      "type": "photo",</p>
<p>      "cid": "QmAbC123...",</p>
<p>      "description": "Pacote lacrado com etiqueta visÃ­vel"</p>
<p>    }</p>
<p>  ],</p>
<p>  "product_condition": {</p>
<p>    "seal": "intact",</p>
<p>    "weight_kg": 1.2,</p>
<p>    "dimensions_cm": [30, 20, 10]</p>
<p>  },</p>
<p>  "observation": "Produto conferido, lacre OK",</p>
<p>  "signers": [</p>
<p>    {</p>
<p>      "role": "Seller",</p>
<p>      "account_id": "5Seller123...",</p>
<p>      "signature": "0xabc123def456...",</p>
<p>      "signature_method": "sr25519"</p>
<p>    },</p>
<p>    {</p>
<p>      "role": "Courier",</p>
<p>      "account_id": "5Courier456...",</p>
<p>      "signature": "0xdef789ghi012...",</p>
<p>      "signature_method": "sr25519"</p>
<p>    }</p>
<p>  ],</p>
<p>  "device_attestation": {</p>
<p>    "platform": "iOS",</p>
<p>    "integrity_token": "eyJhbGc...",</p>
<p>    "app_version": "1.2.3"</p>
<p>  }</p>
<p>}</p>
<pre><code class="language-">
<h3 id="52-ancora-on-chain">5.2 Ã‚ncora On-Chain</h3>
<p>Apenas o <strong>payload_hash</strong> (Blake2-256 do JSON acima) Ã© gravado na blockchain:</p>
</code></pre>rust
<p>pallet_attestation::Attestations::insert(</p>
<p>    order_id,</p>
<p>    OrderStep::HANDOFF_SELLER_TO_COURIER,</p>
<p>    AttestationData {</p>
<p>        payload_hash: blake2_256(&json_bytes),</p>
<p>        signers: vec![</p>
<p>            (seller_account, signature_seller),</p>
<p>            (courier_account, signature_courier),</p>
<p>        ],</p>
<p>        timestamp: current_block,</p>
<p>        metadata: Some(b"ipfs:QmAbC123..."),</p>
<p>    }</p>
<p>);</p>
<pre><code class="language-">
<h3 id="53-privacidade-e-verificabilidade">5.3 Privacidade e Verificabilidade</h3>
<p><strong>Dados Off-Chain</strong> (IPFS ou storage comunitÃ¡rio):</p>
<li>MÃ­dias (fotos, vÃ­deos)</li>
<li>PII (endereÃ§os completos, nomes)</li>
<li>Metadados detalhados</li>
<p><strong>Dados On-Chain</strong>:</p>
<li>Hashes (imutÃ¡veis)</li>
<li>Assinaturas (verificÃ¡veis)</li>
<li>Timestamps (ordem temporal)</li>
<p><strong>BenefÃ­cio</strong>:</p>
<li>âœ… Verificabilidade: Qualquer um pode recomputar hash e checar assinatura</li>
<li>âœ… Privacidade: Dados sensÃ­veis nÃ£o vazam na blockchain pÃºblica</li>
<li>âœ… EficiÃªncia: Blockchain nÃ£o fica sobrecarregada com GBs de fotos</li>
<p><strong>Fase 3 (ZK-PoD)</strong>:</p>
<li>Prova de conhecimento zero de que a entrega ocorreu em regiÃ£o autorizada <strong>sem revelar coordenadas exatas</strong></li>
<p>---</p>
<h2 id="6-maquina-de-estados">6. MÃ¡quina de Estados</h2>
<h3 id="61-diagrama-simplificado">6.1 Diagrama Simplificado</h3>
</code></pre>
<p>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</p>
<p>â”‚   CREATED    â”‚ â† Buyer cria Order + Escrow</p>
<p>â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜</p>
<p>       â”‚ Seller aceita</p>
<p>       â†“</p>
<p>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</p>
<p>â”‚   ACCEPTED   â”‚ â† Courier aplica + deposita stake</p>
<p>â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜</p>
<p>       â”‚ HandoffProof (Seller+Courier)</p>
<p>       â†“</p>
<p>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</p>
<p>â”‚  IN_TRANSIT  â”‚</p>
<p>â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜</p>
<p>       â”‚ DeliveryProof (Courier+Buyer)</p>
<p>       â†“</p>
<p>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</p>
<p>â”‚  DELIVERED   â”‚</p>
<p>â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜</p>
<p>       â”‚ PoCEngine valida quÃ³rum</p>
<p>       â†“</p>
<p>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</p>
<p>â”‚  FINALIZED   â”‚ â† Split, reputaÃ§Ãµes â†‘, eventos</p>
<p>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</p>
<p>       (qualquer falha)</p>
<p>            â†“</p>
<p>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</p>
<p>â”‚   DISPUTE    â”‚ â†’ Jurors â†’ RULING â†’ aplicaÃ§Ã£o</p>
<p>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</p>
<pre><code class="language-">
<h3 id="62-condicoes-de-transicao">6.2 CondiÃ§Ãµes de TransiÃ§Ã£o</h3>
<p>| De | Para | CondiÃ§Ã£o | AÃ§Ã£o On-Chain |</p>
<p>|----|------|----------|---------------|</p>
| </code>CREATED<code> | </code>ACCEPTED<code> | Seller chama </code>accept_order<code> | Atualiza </code>Order.seller_accepted = true<code> |
| </code>ACCEPTED<code> | </code>HANDOFF<code> | Courier selecionado + stake depositado | </code>CourierStakes.insert(order, (courier, stake))<code> |
| </code>HANDOFF<code> | </code>IN_TRANSIT<code> | </code>submit_attestation(HANDOFF)<code> com Seller+Courier | Valida signers, ancora hash |
| </code>IN_TRANSIT<code> | </code>DELIVERED<code> | </code>submit_attestation(DELIVERED)<code> com Courier+Buyer | Valida signers, ancora hash |
| </code>DELIVERED<code> | </code>FINALIZED<code> | </code>finalize(order_id)<code> + quÃ³rum vÃ¡lido | Split escrow, retorna stake, atualiza rep |
| </code>*<code> | </code>DISPUTE<code> | Timeout OU assinaturas conflitantes OU parte chama </code>open_dispute<code> | Cria </code>Dispute<code>, seleciona jurors |
| </code>DISPUTE<code> | </code>RULING_APPLIED<code> | Jurors votam + </code>finalize_dispute<code> | Aplica ruling (release/refund + slashing) |
<p>---</p>
<h2 id="7-fluxos-essenciais">7. Fluxos Essenciais</h2>
<h3 id="71-fluxo-feliz-compra-entrega-liquidacao">7.1 Fluxo Feliz (Compra â†’ Entrega â†’ LiquidaÃ§Ã£o)</h3>
<p><strong>Passo a Passo</strong>:</p>
<p>1. <strong>Buyer Cria Order</strong></p>
   </code>`<code>rust
<p>   Order::create_order(</p>
<p>       origin = Buyer,</p>
<p>       product_id,</p>
<p>       quantity,</p>
<p>       price = 100 BZR,</p>
<p>       escrow_amount = 100 BZR</p>
<p>   )</p>
   </code>`<code>
<p>   - Escrow trava 100 BZR da conta do Buyer</p>
   - Evento: </code>OrderCreated(order_id, buyer, seller, amount)<code>
<p>2. <strong>Seller Aceita</strong></p>
   </code>`<code>rust
<p>   Order::accept_order(origin = Seller, order_id)</p>
   </code>`<code>
   - </code>Order.status = ACCEPTED<code>
<p>   - NotificaÃ§Ã£o para couriers disponÃ­veis</p>
<p>3. <strong>Courier Aplica e Deposita Stake</strong></p>
   </code>`<code>rust
<p>   Fulfillment::apply_as_courier(origin = Courier, order_id)</p>
<p>   Fulfillment::deposit_stake(origin = Courier, order_id, stake = 20 BZR)</p>
   </code>`<code>
<p>   - Seller escolhe Courier (ou sistema auto-assign por reputaÃ§Ã£o)</p>
   - </code>CourierStakes.insert(order, (courier, 20 BZR))<code>
<p>4. <strong>Handoff: Seller Entrega ao Courier</strong></p>
<p>   - BazChat abre tela de co-assinatura</p>
<p>   - Seller e Courier tiram foto do pacote</p>
<p>   - App gera JSON, ambos assinam</p>
<p>   - App chama:</p>
   </code>`<code>rust
<p>   Attestation::submit_attestation(</p>
<p>       origin = Either(Seller ou Courier),</p>
<p>       order_id,</p>
<p>       step = HANDOFF,</p>
<p>       payload_hash,</p>
<p>       signatures = [(Seller, sig1), (Courier, sig2)]</p>
<p>   )</p>
   </code>`<code>
<p>   - ValidaÃ§Ã£o on-chain: signers corretos? hash vÃ¡lido?</p>
   - </code>Order.status = IN_TRANSIT<code>
<p>5. <strong>Delivery: Courier Entrega ao Buyer</strong></p>
<p>   - BazChat abre tela de co-assinatura</p>
<p>   - Courier e Buyer tiram foto/assinatura de recebimento</p>
<p>   - App gera JSON, ambos assinam</p>
<p>   - App chama:</p>
   </code>`<code>rust
<p>   Attestation::submit_attestation(</p>
<p>       origin = Either(Courier ou Buyer),</p>
<p>       order_id,</p>
<p>       step = DELIVERED,</p>
<p>       payload_hash,</p>
<p>       signatures = [(Courier, sig1), (Buyer, sig2)]</p>
<p>   )</p>
   </code>`<code>
   - </code>Order.status = DELIVERED<code>
<p>6. <strong>FinalizaÃ§Ã£o AutomÃ¡tica</strong></p>
   </code>`<code>rust
<p>   PoCEngine::finalize(order_id)</p>
   </code>`<code>
<p>   - Valida que existe:</p>
     - </code>ORDER_CREATED<code> (implÃ­cito)
     - </code>HANDOFF<code> com Seller+Courier
     - </code>DELIVERED<code> com Courier+Buyer
<p>   - Se vÃ¡lido:</p>
<p>     - Split escrow:</p>
<p>       - Seller: 100 BZR (preÃ§o produto)</p>
<p>       - Courier: 15 BZR (frete)</p>
<p>       - Affiliates: 5 BZR (comissÃ£o 5%)</p>
<p>       - DAO: 2 BZR (taxa 2%)</p>
<p>     - Retorna stake do Courier (20 BZR)</p>
<p>     - Atualiza reputaÃ§Ãµes:</p>
       - </code>SellerScore += 10<code>
       - </code>CourierScore += 10<code>
       - </code>BuyerScore += 1<code> (nÃ£o deu no-show)
   - Evento: </code>OrderFinalized(order_id, splits)<code>
<p><strong>Tempo Total</strong>: Segundos (confirmaÃ§Ã£o de 2 blocos Substrate, ~12s)</p>
<p>---</p>
<h3 id="72-fluxo-de-disputa">7.2 Fluxo de Disputa</h3>
<p><strong>Trigger</strong>: Qualquer das condiÃ§Ãµes:</p>
<li>Timeout sem atestado (ex.: 7 dias sem DELIVERED)</li>
<li>Assinaturas conflitantes</li>
<li>Parte chama </code>open_dispute<code> explicitamente</li>
<p><strong>Passo a Passo</strong>:</p>
<p>1. <strong>Abertura</strong></p>
   </code>`<code>rust
<p>   Dispute::open_dispute(</p>
<p>       origin = Buyer | Seller | Courier,</p>
<p>       order_id,</p>
<p>       reason = "Product damaged",</p>
<p>       evidence_cids = ["QmEvidence1", "QmEvidence2"]</p>
<p>   )</p>
   </code>`<code>
   - </code>Order.status = DISPUTE_OPENED<code>
   - Evento: </code>DisputeOpened(order_id, opener, reason)<code>
<p>2. <strong>SeleÃ§Ã£o de Jurors (Fase 2: VRF)</strong></p>
   </code>`<code>rust
<p>   // VRF gera aleatoriedade verificÃ¡vel</p>
<p>   let random_seed = VRF::get_randomness(block_number, order_id);</p>
<p>   let jurors = JurorPool::select_random(7, random_seed);</p>
<p>   Dispute::assign_jurors(order_id, jurors)</p>
   </code>`<code>
<p>   - Jurors sÃ£o notificados</p>
<p>   - Prazo para anÃ¡lise: 48h</p>
<p>3. <strong>AnÃ¡lise de EvidÃªncias</strong></p>
<p>   Jurors recebem:</p>
<p>   - Hashes on-chain de todas as attestations</p>
<p>   - CIDs IPFS das mÃ­dias</p>
<p>   - Timeline do pedido</p>
<p>   - Scorecards prÃ©-computados (Fase 3: IA assistiva)</p>
<p>4. <strong>Voto Commit-Reveal (anti-suborno)</strong></p>
<p>   - <strong>Commit</strong>: Juror envia hash do voto</p>
   </code>`<code>rust
<p>   Dispute::commit_vote(</p>
<p>       origin = Juror,</p>
<p>       order_id,</p>
<p>       vote_hash = blake2_256(vote || salt)</p>
<p>   )</p>
   </code>`<code>
<p>   - <strong>Reveal</strong>: ApÃ³s todos commitarem, revela voto</p>
   </code>`<code>rust
<p>   Dispute::reveal_vote(</p>
<p>       origin = Juror,</p>
<p>       order_id,</p>
<p>       vote = RefundBuyer,  // ou ReleaseSeller</p>
<p>       salt,</p>
<p>       justification_hash</p>
<p>   )</p>
   </code>`<code>
<p>5. <strong>Ruling</strong></p>
   </code>`<code>rust
<p>   Dispute::finalize_dispute(order_id)</p>
   </code>`<code>
<p>   - Contabiliza votos (maioria simples ou supermaioria 2/3)</p>
<p>   - Aplica ruling:</p>
<p>     - <strong>RefundBuyer</strong>: Escrow retorna ao Buyer; Slashing de Seller/Courier se culpa comprovada</p>
<p>     - <strong>ReleaseSeller</strong>: Split normal; Slashing de reputaÃ§Ã£o do Buyer</p>
<p>     - <strong>Partial</strong>: Split proporcional</p>
<p>   - Atualiza reputaÃ§Ãµes de todos (incluindo jurors: acertaram ou nÃ£o?)</p>
   - Evento: </code>DisputeResolved(order_id, ruling, slashes)<code>
<p><strong>Tempo Total</strong>: 2-7 dias (dependendo de complexidade)</p>
<p>---</p>
<h2 id="8-sistema-de-afiliados">8. Sistema de Afiliados</h2>
<h3 id="81-modelo-dag-merkle-trees">8.1 Modelo DAG + Merkle Trees</h3>
<p><strong>Problema</strong>: Como provar cadeia de compartilhamento sem armazenar gigabytes on-chain?</p>
<p><strong>SoluÃ§Ã£o</strong>: Directed Acyclic Graph (DAG) off-chain + Merkle root on-chain</p>
</code></pre>
<p>Campanha criada por Seller:</p>
<p>  - Taxa: 5%</p>
<p>  - Max hops: 5</p>
<p>  - Decay: 50% por nÃ­vel</p>
<p>DAG de compartilhamentos:</p>
<p>Seller (root)</p>
<p>  â”œâ”€ Affiliate1 (nÃ­vel 1, 2.5%)</p>
<p>  â”‚   â”œâ”€ Affiliate2 (nÃ­vel 2, 1.25%)</p>
<p>  â”‚   â””â”€ Affiliate3 (nÃ­vel 2, 1.25%)</p>
<p>  â””â”€ Affiliate4 (nÃ­vel 1, 2.5%)</p>
<p>      â””â”€ Affiliate5 (nÃ­vel 2, 1.25%)</p>
<p>Merkle Root = Hash(todos os nÃ³s e arestas)</p>
<p>â†’ Publicado on-chain</p>
<pre><code class="language-">
<h3 id="82-inclusao-no-order">8.2 InclusÃ£o no Order</h3>
<p>Quando Buyer compra via link de Affiliate5:</p>
</code></pre>rust
<p>Order::create_order_with_affiliate(</p>
<p>    ...</p>
<p>    affiliate_path = MerkleProof {</p>
<p>        campaign_id,</p>
<p>        path: [Affiliate1, Affiliate2, Affiliate5],</p>
<p>        proof: [hash1, hash2, hash3],  // siblings necessÃ¡rios</p>
<p>        root: 0xabc123...  // corresponde ao publicado</p>
<p>    }</p>
<p>)</p>
<pre><code class="language-">
<h3 id="83-validacao-e-split">8.3 ValidaÃ§Ã£o e Split</h3>
</code></pre>rust
<p>fn validate_and_split_affiliates(order: &Order) -> Result<Vec<(AccountId, Balance)>, Error> {</p>
<p>    let campaign = Campaigns::get(order.affiliate_path.campaign_id)?;</p>
<p>    // 1. Valida Merkle proof</p>
<p>    ensure!(</p>
<p>        verify_merkle_proof(</p>
<p>            order.affiliate_path.proof,</p>
<p>            order.affiliate_path.root,</p>
<p>            order.affiliate_path.path</p>
<p>        ),</p>
<p>        "Invalid Merkle proof"</p>
<p>    );</p>
<p>    // 2. Verifica hops <= max</p>
<p>    ensure!(</p>
<p>        order.affiliate_path.path.len() <= campaign.max_hops,</p>
<p>        "Exceeded max hops"</p>
<p>    );</p>
<p>    // 3. Verifica stakes/reputaÃ§Ã£o mÃ­nima</p>
<p>    for affiliate in &order.affiliate_path.path {</p>
<p>        ensure!(</p>
<p>            AffiliateScores::get(affiliate) >= campaign.min_score,</p>
<p>            "Affiliate below min reputation"</p>
<p>        );</p>
<p>    }</p>
<p>    // 4. Calcula splits com decay</p>
<p>    let total_commission = order.amount * campaign.rate / 100;</p>
<p>    let mut payouts = Vec::new();</p>
<p>    let mut remaining = total_commission;</p>
<p>    for (level, affiliate) in order.affiliate_path.path.iter().enumerate() {</p>
<p>        let share = remaining * campaign.decay_per_level.pow(level);</p>
<p>        payouts.push((affiliate.clone(), share));</p>
<p>        remaining -= share;</p>
<p>    }</p>
<p>    Ok(payouts)</p>
<p>}</p>
<pre><code class="language-">
<h3 id="84-anti-spam">8.4 Anti-Spam</h3>
<li><strong>Stake mÃ­nimo</strong>: Cada afiliado precisa ter X BZR travado</li>
<li><strong>ReputaÃ§Ã£o mÃ­nima</strong>: AffiliateScore >= threshold</li>
<li><strong>DetecÃ§Ã£o de loops</strong>: Mesmo account_id nÃ£o pode aparecer 2x no caminho</li>
<li><strong>Limite de hops</strong>: Configurable por campanha (tÃ­pico: 3-5)</li>
<p>---</p>
<h2 id="9-sistema-de-reputacao">9. Sistema de ReputaÃ§Ã£o</h2>
<h3 id="91-poc-score-por-papel">9.1 PoC Score por Papel</h3>
<p>Cada entidade tem score independente para cada papel que desempenha:</p>
<p>| Score | Range | Significado |</p>
<p>|-------|-------|-------------|</p>
<p>| <strong>SellerScore</strong> | 0-1000 | Qualidade de produtos, tempo de confirmaÃ§Ã£o, taxa de disputas |</p>
<p>| <strong>CourierScore</strong> | 0-1000 | Pontualidade, cuidado com produtos, taxa de sucesso |</p>
<p>| <strong>BuyerScore</strong> | 0-1000 | Confiabilidade (nÃ£o dÃ¡ no-show), nÃ£o abre disputas frÃ­volas |</p>
<p>| <strong>AffiliateScore</strong> | 0-1000 | Taxa de conversÃ£o real (vs. spam) |</p>
<h3 id="92-inputs-do-score">9.2 Inputs do Score</h3>
</code></pre>rust
<p>struct ReputationInputs {</p>
<p>    // Positivos</p>
<p>    successful_completions: u32,      // +10 por pedido sem disputa</p>
<p>    on_time_deliveries: u32,          // +5 se entrega dentro do SLA</p>
<p>    positive_feedback: u32,           // +3 por avaliaÃ§Ã£o 5 estrelas</p>
<p>    // Negativos</p>
<p>    disputes_opened_against: u32,     // -20 por disputa aberta contra vocÃª</p>
<p>    disputes_lost: u32,               // -50 se jÃºri decide contra vocÃª</p>
<p>    timeouts: u32,                    // -15 por timeout (nÃ£o respondeu)</p>
<p>    slashes: Balance,                 // -100 por 1% do stake slashado</p>
<p>    // Temporal</p>
<p>    last_activity: BlockNumber,       // Decay se ficar inativo</p>
<p>    account_age: BlockNumber,         // BÃ´nus por longevidade</p>
<p>}</p>
<pre><code class="language-">
<h3 id="93-formula-simplificada">9.3 FÃ³rmula (simplificada)</h3>
</code></pre>rust
<p>fn calculate_score(inputs: ReputationInputs) -> u32 {</p>
<p>    let base = 500;  // Score inicial</p>
<p>    let positive = inputs.successful_completions * 10</p>
<p>                 + inputs.on_time_deliveries * 5</p>
<p>                 + inputs.positive_feedback * 3;</p>
<p>    let negative = inputs.disputes_opened_against * 20</p>
<p>                 + inputs.disputes_lost * 50</p>
<p>                 + inputs.timeouts * 15</p>
<p>                 + (inputs.slashes / UNIT) as u32 * 100;</p>
<p>    let decay = if inputs.last_activity < current_block - DECAY_THRESHOLD {</p>
<p>        (current_block - inputs.last_activity) / DECAY_FACTOR</p>
<p>    } else {</p>
<p>        0</p>
<p>    };</p>
<p>    let age_bonus = min(inputs.account_age / AGE_FACTOR, 50);</p>
<p>    let score = base + positive - negative - decay + age_bonus;</p>
<p>    score.clamp(0, 1000)</p>
<p>}</p>
<pre><code class="language-">
<h3 id="94-uso-dos-scores">9.4 Uso dos Scores</h3>
<p><strong>Gates DinÃ¢micos</strong>:</p>
<p>| Score | Valor MÃ¡x/Pedido | Stake Courier Exigido | Visibilidade |</p>
<p>|-------|------------------|----------------------|--------------|</p>
<p>| 0-200 | 50 BZR | 50% do valor | Baixa no ranking |</p>
<p>| 200-500 | 500 BZR | 20% do valor | MÃ©dia |</p>
<p>| 500-800 | 5000 BZR | 10% do valor | Alta |</p>
<p>| 800-1000 | Sem limite | 5% do valor | Destaque no marketplace |</p>
<p><strong>SeleÃ§Ã£o Preferencial</strong>:</p>
<li>Couriers com score alto aparecem primeiro nas buscas</li>
<li>Sellers com score alto tÃªm produtos promovidos</li>
<li>Afiliados com score alto recebem taxas de comissÃ£o maiores</li>
<p>---</p>
<h2 id="10-economia-e-seguranca">10. Economia e SeguranÃ§a</h2>
<h3 id="101-escrow-obrigatorio">10.1 Escrow ObrigatÃ³rio</h3>
<p><strong>Regra de Ouro</strong>: Sem escrow, nÃ£o hÃ¡ handoff.</p>
</code></pre>rust
<p>fn accept_order(origin, order_id) -> DispatchResult {</p>
<p>    let order = Orders::get(order_id)?;</p>
<p>    ensure!(</p>
<p>        Escrow::Locks::contains_key(order_id),</p>
<p>        "Escrow must be deposited before acceptance"</p>
<p>    );</p>
<p>    ensure!(</p>
<p>        Escrow::Locks::get(order_id) >= order.total_amount,</p>
<p>        "Insufficient escrow"</p>
<p>    );</p>
<p>    // ... restante da lÃ³gica</p>
<p>}</p>
<pre><code class="language-">
<h3 id="102-stake-de-courier">10.2 Stake de Courier</h3>
<p><strong>PropÃ³sito</strong>: Skin in the game + colateral para slashing</p>
<strong>CÃ¡lculo DinÃ¢mico</strong>:</code></pre>rust
<p>fn calculate_required_stake(order_value: Balance, courier_score: u32) -> Balance {</p>
<p>    let base_rate = 0.2;  // 20%</p>
<p>    let score_factor = (1000 - courier_score) / 1000;  // quanto menor score, maior stake</p>
<p>    let rate = base_rate * (1.0 + score_factor);</p>
<p>    order_value * rate</p>
<p>}</p>
<pre><code class="language-">
<p><strong>Exemplo</strong>:</p>
<li>Order de 100 BZR</li>
<li>Courier com score 800 (alto)</li>
<li>Stake exigido: 100 <em> 0.2 </em> (1 + 0.2) = 24 BZR</li>
<li>Courier com score 300 (baixo)</li>
<li>Stake exigido: 100 <em> 0.2 </em> (1 + 0.7) = 34 BZR</li>
<h3 id="103-slashing">10.3 Slashing</h3>
<p><strong>CenÃ¡rios de Slashing</strong>:</p>
<p>| InfraÃ§Ã£o | Penalidade | Quem Perde |</p>
<p>|----------|-----------|------------|</p>
<p>| Handoff forjado (prova falsa) | 50-100% do stake | Courier |</p>
<p>| Delivery nÃ£o realizada (culpa provada) | 30-50% do stake | Courier |</p>
<p>| Produto trocado/defeituoso | Perda de reputaÃ§Ã£o + possÃ­vel ban | Seller |</p>
<p>| Disputa frÃ­vola (mÃ¡-fÃ© comprovada) | Taxa de disputa nÃ£o devolvida + rep-- | Buyer |</p>
<p>| Juror vota contra evidÃªncias Ã³bvias | 20% do stake de juror | Juror |</p>
<strong>Slashing Ã© Progressivo</strong>:</code></pre>rust
<p>fn calculate_slash_amount(</p>
<p>    base_stake: Balance,</p>
<p>    infraction_severity: u8,  // 1-10</p>
<p>    repeat_offender: bool</p>
<p>) -> Balance {</p>
<p>    let severity_factor = infraction_severity as f64 / 10.0;</p>
<p>    let repeat_multiplier = if repeat_offender { 2.0 } else { 1.0 };</p>
<p>    (base_stake <em> severity_factor </em> repeat_multiplier).min(base_stake)</p>
<p>}</p>
<pre><code class="language-">
<h3 id="104-fees-taxas">10.4 Fees (Taxas)</h3>
<p><strong>ConfiguraÃ§Ã£o DAO-governed</strong>:</p>
</code></pre>rust
<p>struct FeeConfig {</p>
<p>    dao_fee_percent: u8,           // ex.: 2%</p>
<p>    treasury_percent: u8,          // ex.: 1%</p>
<p>    juror_pool_percent: u8,        // ex.: 0.5%</p>
<p>    burn_percent: u8,              // ex.: 0.5% (deflaÃ§Ã£o)</p>
<p>}</p>
<pre><code class="language-">
<strong>DistribuiÃ§Ã£o no </code>finalize()<code></strong>:</code></pre>rust
<p>let total = escrow_amount;</p>
<p>let dao_fee = total * config.dao_fee_percent / 100;</p>
<p>let treasury_fee = total * config.treasury_percent / 100;</p>
<p>// ...</p>
<p>Escrow::transfer(dao_account, dao_fee);</p>
<p>Escrow::transfer(treasury_account, treasury_fee);</p>
<p>Escrow::burn(total * config.burn_percent / 100);</p>
<pre><code class="language-">
<p>---</p>
<h2 id="11-invariantes-de-protocolo">11. Invariantes de Protocolo</h2>
<p><strong>Invariantes</strong> sÃ£o propriedades que <strong>nunca</strong> podem ser violadas. Se forem, o protocolo estÃ¡ comprometido.</p>
<h3 id="111-invariantes-economicos">11.1 Invariantes EconÃ´micos</h3>
<p>1. <strong>ConservaÃ§Ã£o de Valor</strong></p>
   </code>`<code>
<p>   âˆ‘(Escrow bloqueados) + âˆ‘(Stakes de couriers) = âˆ‘(Saldos antes dos locks)</p>
   </code>`<code>
<p>   - Nenhum BZR pode ser criado ou destruÃ­do fora de mint/burn autorizados</p>
<p>2. <strong>Split Total Correto</strong></p>
   </code>`<code>
<p>   ApÃ³s finalize():</p>
<p>   Seller recebido + Courier recebido + Affiliates recebidos + Taxas = Escrow original</p>
   </code>`<code>
<p>3. <strong>Stake Sempre Retornado (se sem culpa)</strong></p>
   </code>`<code>
<p>   Se Courier nÃ£o foi slashado â‡’ Stake Ã© devolvido integralmente</p>
   </code>`<code>
<h3 id="112-invariantes-de-autorizacao">11.2 Invariantes de AutorizaÃ§Ã£o</h3>
<p>4. <strong>Apenas Signers VÃ¡lidos Podem Atestar</strong></p>
   </code>`<code>
<p>   submit_attestation(HANDOFF, [sigA, sigB]) â‡’</p>
<p>     sigA âˆˆ {Seller, Courier} âˆ§ sigB âˆˆ {Seller, Courier} âˆ§ sigA â‰  sigB</p>
   </code>`<code>
<p>5. <strong>NinguÃ©m Recebe Sem QuÃ³rum</strong></p>
   </code>`<code>
<p>   finalize() sÃ³ executa se âˆƒ:</p>
<p>     - Attestation(ORDER_CREATED)</p>
<p>     - Attestation(HANDOFF) com [Seller, Courier]</p>
<p>     - Attestation(DELIVERED) com [Courier, Buyer]</p>
   </code>`<code>
<h3 id="113-invariantes-de-estado">11.3 Invariantes de Estado</h3>
<p>6. <strong>IdempotÃªncia de FinalizaÃ§Ã£o</strong></p>
   </code>`<code>
<p>   finalize(order_id) chamado 2x â‡’ segunda chamada falha (Order.status jÃ¡ FINALIZED)</p>
   </code>`<code>
<p>7. <strong>Ordem MonotÃ´nica de Steps</strong></p>
   </code>`<code>
<p>   DELIVERED nÃ£o pode ocorrer antes de HANDOFF</p>
<p>   (verificaÃ§Ã£o de timestamp e dependÃªncias)</p>
   </code>`<code>
<p>8. <strong>Timeout Antes de FinalizaÃ§Ã£o ForÃ§ada</strong></p>
   </code>`<code>
<p>   finalize() sem DELIVERED â‡’ SÃ³ se timeout expirado OU ruling de disputa</p>
   </code>`<code>
<h3 id="114-invariantes-de-seguranca">11.4 Invariantes de SeguranÃ§a</h3>
<p>9. <strong>ProteÃ§Ã£o a ReentrÃ¢ncia</strong></p>
   </code>`<code>
<p>   finalize() usa mutex on-chain (ex.: status flag):</p>
<p>   if Order.finalizing { return Err(ReentrancyGuard) }</p>
<p>   Order.finalizing = true;</p>
<p>   // ... executa split</p>
<p>   Order.finalizing = false;</p>
<p>   Order.status = FINALIZED;</p>
   </code>`<code>
<p>10. <strong>Challenge Window</strong></p>
    </code>`<code>
<p>    ApÃ³s DELIVERED, existe janela de 24-48h antes de finalize() automÃ¡tico</p>
<p>    â†’ Permite que partes abram disputas se houver problema</p>
    </code>`<code>
<p>---</p>
<h2 id="12-exemplos-praticos-detalhados">12. Exemplos PrÃ¡ticos Detalhados</h2>
<h3 id="121-caso-a-entrega-no-condominio">12.1 Caso A: "Entrega no CondomÃ­nio"</h3>
<p><strong>SituaÃ§Ã£o</strong>:</p>
<li>Courier entrega pacote ao porteiro Ã s 14h</li>
<li>Buyer chega em casa Ã s 20h e afirma nÃ£o ter recebido</li>
<p><strong>Provas Coletadas</strong>:</p>
<strong>DeliveryProof</strong>:</code></pre>json
<p>{</p>
<p>  "order_id": "0xABC",</p>
<p>  "step": "DELIVERED",</p>
<p>  "timestamp": "2025-10-28T14:00:00Z",</p>
<p>  "geo": {"lat": -23.550, "lon": -46.633},</p>
<p>  "media": [{</p>
<p>    "cid": "QmPhoto1",</p>
<p>    "description": "Pacote com etiqueta #ABC visÃ­vel"</p>
<p>  }],</p>
<p>  "recipient": {</p>
<p>    "name": "JoÃ£o Silva (Porteiro)",</p>
<p>    "id_type": "CPF_partial",</p>
<p>    "signature_capture": "QmSig1"</p>
<p>  },</p>
<p>  "observation": "Entregue ao porteiro - Buyer ausente",</p>
<p>  "signers": [</p>
<p>    {"account": "5Courier", "sig": "0x..."},</p>
<p>    {"account": "5Buyer", "sig": null}  // Buyer nÃ£o presente</p>
<p>  ]</p>
<p>}</p>
<pre><code class="language-">
<p><strong>AÃ§Ã£o do Courier</strong>:</p>
<li>Como Buyer nÃ£o estava presente, Courier fotografou:</li>
<p>  1. Etiqueta do pacote</p>
<p>  2. Rosto do porteiro (blur automÃ¡tico no app)</p>
<p>  3. Assinatura digital do porteiro</p>
<li>Submeteu attestation com observaÃ§Ã£o</li>
<p><strong>Fluxo</strong>:</p>
<p>1. Courier submete DeliveryProof Ã s 14h05</p>
<p>2. Sistema detecta que falta assinatura do Buyer</p>
<p>3. Inicia timer de 48h para Buyer co-assinar OU abrir disputa</p>
<p>4. Buyer Ã s 20h vÃª notificaÃ§Ã£o no app: "Seu pedido foi entregue ao porteiro"</p>
<p>5. Buyer pode:</p>
<p>   - <strong>OpÃ§Ã£o A</strong>: Confirmar que retirou (co-assinar tardiamente) â†’ finaliza</p>
<p>   - <strong>OpÃ§Ã£o B</strong>: Abrir disputa "NÃ£o encontrei o pacote"</p>
<p><strong>Se Disputa Ã© Aberta</strong>:</p>
<li>Jurors analisam:</li>
<p>  - âœ… Foto da etiqueta corresponde ao order_id</p>
<p>  - âœ… Timestamp e geo corretos (portaria do condomÃ­nio)</p>
<p>  - âœ… Porteiro identificado (prÃ¡tica comum)</p>
<p>  - âŒ Buyer nÃ£o tem contra-evidÃªncia (nÃ£o fotografou ausÃªncia do pacote)</p>
<li><strong>Ruling</strong>: Release para Seller e Courier (entrega vÃ¡lida)</li>
<li><strong>AÃ§Ã£o educativa</strong>: Buyer instruÃ­do a retirar com portaria</li>
<p>---</p>
<h3 id="122-caso-b-lacre-violado-no-trajeto">12.2 Caso B: "Lacre Violado no Trajeto"</h3>
<p><strong>SituaÃ§Ã£o</strong>:</p>
<li>Seller lacra caixa com produto (tÃªnis Nike)</li>
<li>Courier transporta</li>
<li>Buyer recebe caixa amassada com lacre rompido</li>
<p><strong>Provas</strong>:</p>
<strong>HandoffProof</strong> (Seller â†’ Courier):</code></pre>json
<p>{</p>
<p>  "step": "HANDOFF",</p>
<p>  "timestamp": "2025-10-28T09:00:00Z",</p>
<p>  "media": [</p>
<p>    {"cid": "QmLacre1", "description": "Lacre intacto, sÃ©rie #12345"},</p>
<p>    {"cid": "QmCaixa1", "description": "Caixa em perfeito estado"}</p>
<p>  ],</p>
<p>  "product_condition": {</p>
<p>    "seal": "intact",</p>
<p>    "seal_number": "12345",</p>
<p>    "weight_kg": 1.0</p>
<p>  },</p>
<p>  "signers": [</p>
<p>    {"account": "5Seller", "sig": "0x..."},</p>
<p>    {"account": "5Courier", "sig": "0x..."}</p>
<p>  ]</p>
<p>}</p>
<pre><code class="language-">
<strong>DeliveryProof</strong> (Courier â†’ Buyer):</code></pre>json
<p>{</p>
<p>  "step": "DELIVERED",</p>
<p>  "timestamp": "2025-10-28T16:00:00Z",</p>
<p>  "media": [</p>
<p>    {"cid": "QmLacre2", "description": "Lacre rompido"},</p>
<p>    {"cid": "QmCaixa2", "description": "Caixa amassada"}</p>
<p>  ],</p>
<p>  "product_condition": {</p>
<p>    "seal": "broken",</p>
<p>    "damage": "box_crushed"</p>
<p>  },</p>
<p>  "observation": "Buyer recusou assinar devido a dano visÃ­vel",</p>
<p>  "signers": [</p>
<p>    {"account": "5Courier", "sig": "0x..."},</p>
<p>    {"account": "5Buyer", "sig": null}  // Recusa proposital</p>
<p>  ]</p>
<p>}</p>
<pre><code class="language-">
<p><strong>Fluxo</strong>:</p>
<p>1. Buyer nÃ£o assina DeliveryProof na hora (recusa)</p>
<p>2. Courier submete attestation com observaÃ§Ã£o de recusa</p>
<p>3. Sistema abre Dispute automÃ¡tica (co-assinatura faltante + dano alegado)</p>
<p>4. Jurors recebem ambas as provas</p>
<p><strong>AnÃ¡lise do JÃºri</strong>:</p>
<li><strong>HandoffProof</strong> mostra:</li>
<p>  - âœ… Lacre #12345 intacto</p>
<p>  - âœ… Caixa perfeita</p>
<p>  - âœ… Ambos assinaram (Seller e Courier concordam com estado)</p>
<li><strong>DeliveryProof</strong> mostra:</li>
<p>  - âŒ Lacre rompido</p>
<p>  - âŒ Caixa amassada</p>
<p>  - ğŸ“¸ Fotos timestamped provam mudanÃ§a de estado</p>
<p><strong>ConclusÃ£o</strong>:</p>
<li>Dano ocorreu <strong>entre HANDOFF e DELIVERY</strong></li>
<li>Responsabilidade: <strong>Courier</strong> (Ãºnico custÃ³dia no perÃ­odo)</li>
<strong>Ruling</strong>:</code></pre>rust
<p>Ruling::PartialRefund {</p>
<p>    buyer_refund: 100 BZR (valor total),</p>
<p>    seller_payment: 100 BZR (nÃ£o teve culpa),</p>
<p>    courier_slash: 50 BZR (50% do stake de 100 BZR),</p>
<p>    source: Courier stake + seguro/pool</p>
<p>}</p>
<pre><code class="language-">
<p><strong>ExecuÃ§Ã£o</strong>:</p>
<li>Buyer recebe 100 BZR de volta</li>
<li>Seller recebe 100 BZR do escrow</li>
<li>Courier perde 50 BZR do stake (slashing)</li>
<li>Courier recebe 50 BZR de volta + reputaÃ§Ã£o -100 pontos</li>
<li>Se o pool de seguro existir, cobre a diferenÃ§a; senÃ£o, Courier arca sozinho</li>
<p>---</p>
<h3 id="123-caso-c-afiliado-spammer">12.3 Caso C: "Afiliado Spammer"</h3>
<p><strong>SituaÃ§Ã£o</strong>:</p>
<li>Spammer cria 30 contas falsas</li>
<li>Tenta criar cadeia artificial de compartilhamentos para inflar comissÃ£o</li>
<strong>Tentativa</strong>:</code></pre>
<p>Seller â†’ Fake1 â†’ Fake2 â†’ ... â†’ Fake30 â†’ Buyer</p>
<pre><code class="language-">
<strong>Campanha Configurada</strong>:</code></pre>rust
<p>Campaign {</p>
<p>    rate: 5%,</p>
<p>    max_hops: 5,</p>
<p>    decay: 0.5,  // 50% por nÃ­vel</p>
<p>    min_score: 100,</p>
<p>    min_stake: 10 BZR</p>
<p>}</p>
<pre><code class="language-">
<strong>Order Criado</strong>:</code></pre>rust
<p>Order::create_order_with_affiliate(</p>
<p>    affiliate_path = MerkleProof {</p>
<p>        campaign_id: 123,</p>
<p>        path: [Fake1, Fake2, ..., Fake30],  // 30 hops</p>
<p>        proof: [...],</p>
<p>        root: 0xSpamRoot</p>
<p>    }</p>
<p>)</p>
<pre><code class="language-">
<p><strong>ValidaÃ§Ã£o On-Chain</strong>:</p>
</code></pre>rust
<p>// 1. Verifica Merkle proof</p>
<p>verify_merkle_proof(path, proof, root) âœ… (spammer publicou root)</p>
<p>// 2. Verifica hops</p>
<p>path.len() = 30 > max_hops = 5 âŒ</p>
<p>// FALHA: "Exceeded max hops"</p>
<p>// 3. Mesmo que passasse hops, verifica reputaÃ§Ã£o</p>
<p>for fake in path {</p>
<p>    AffiliateScores::get(fake) = 0 < min_score = 100 âŒ</p>
<p>}</p>
<p>// FALHA: "Affiliate below min reputation"</p>
<p>// 4. Verifica stakes</p>
<p>for fake in path {</p>
<p>    AffiliateStakes::get(fake) = 0 < min_stake = 10 BZR âŒ</p>
<p>}</p>
<p>// FALHA: "Affiliate below min stake"</p>
<pre><code class="language-">
<p><strong>Resultado</strong>:</p>
<li>Order Ã© criado, mas </code>affiliate_path<code> Ã© rejeitado</li>
<li>ComissÃµes vÃ£o para NULL ou sÃ£o queimadas</li>
<li>Spammer nÃ£o recebe nada</li>
<li>Se tentou stake com fundos roubados, pode acionar investigaÃ§Ã£o</li>
<p><strong>ProteÃ§Ã£o Adicional (Fase 2)</strong>:</p>
<li>DetecÃ§Ã£o de padrÃµes (mesmas contas sempre trabalhando juntas)</li>
<li>Stake slashado se comprovado spam</li>
<li>Ban de IPs/dispositivos associados</li>
<p>---</p>
<h2 id="13-hardening-do-modulo-de-disputas">13. Hardening do MÃ³dulo de Disputas</h2>
<h3 id="131-o-vetor-mais-sensivel">13.1 O Vetor Mais SensÃ­vel</h3>
<p><strong>CrÃ­tica comum</strong>: "Se o jÃºri pode ser subornado ou toma decisÃµes inconsistentes, o PoC falha."</p>
<p><strong>Resposta</strong>: O mÃ³dulo de Disputas Ã© a <strong>Ãºltima linha de defesa</strong>, acionada apenas quando o PoCEngine nÃ£o consegue decidir automaticamente (~5-10% dos pedidos). Por isso, tem mÃºltiplas camadas de proteÃ§Ã£o.</p>
<p>---</p>
<h3 id="132-mitigacoes-anti-suborno">13.2 MitigaÃ§Ãµes Anti-Suborno</h3>
<h4 id="a-selecao-aleatoria-verificavel-vrf">A) SeleÃ§Ã£o AleatÃ³ria VerificÃ¡vel (VRF)</h4>
<p><strong>Problema</strong>: Se atacante sabe quem serÃ£o os jurors, pode tentar corromper.</p>
<strong>SoluÃ§Ã£o</strong>:</code></pre>rust
<p>// Usa VRF (Verifiable Random Function) - imprevisÃ­vel e verificÃ¡vel</p>
<p>let random_seed = pallet_babe::RandomnessFromOneEpochAgo::<T>::random(&order_id);</p>
<p>let pool = JurorPool::get();  // todos os stakers elegÃ­veis</p>
<p>let selected = select_random_subset(pool, 7, random_seed);</p>
<pre><code class="language-">
<p><strong>Propriedades</strong>:</p>
<li>NinguÃ©m pode prever quem serÃ¡ selecionado antes da seleÃ§Ã£o</li>
<li>ApÃ³s seleÃ§Ã£o, todos podem verificar que foi aleatÃ³ria (VRF proof)</li>
<p>---</p>
<h4 id="b-commit-reveal-voto-secreto">B) Commit-Reveal + Voto Secreto</h4>
<p><strong>Problema</strong>: Se jurors votam publicamente, podem ser pressionados a mudar voto.</p>
<strong>SoluÃ§Ã£o</strong>:</code></pre>rust
<p>// Fase 1: Commit (juror envia hash do voto)</p>
<p>fn commit_vote(origin, order_id: OrderId, vote_hash: H256) {</p>
<p>    let juror = ensure_signed(origin)?;</p>
<p>    VoteCommits::insert((order_id, juror), VoteCommit {</p>
<p>        hash: vote_hash,</p>
<p>        timestamp: now()</p>
<p>    });</p>
<p>}</p>
<p>// Fase 2: Reveal (apÃ³s todos commitarem, revela voto)</p>
<p>fn reveal_vote(origin, order_id: OrderId, vote: Vote, salt: Vec<u8>) {</p>
<p>    let juror = ensure_signed(origin)?;</p>
<p>    let commit = VoteCommits::get((order_id, juror))?;</p>
<p>    // Verifica que hash corresponde</p>
<p>    ensure!(</p>
<p>        blake2_256(&(vote, salt)) == commit.hash,</p>
<p>        "Invalid reveal"</p>
<p>    );</p>
<p>    Votes::insert((order_id, juror), vote);</p>
<p>}</p>
<pre><code class="language-">
<p><strong>Propriedades</strong>:</p>
<li>Durante commit, ninguÃ©m sabe o voto de ninguÃ©m</li>
<li>ImpossÃ­vel mudar voto depois do commit (hash travou)</li>
<li>RevelaÃ§Ã£o prova que o voto Ã© o mesmo que foi commitado</li>
<p>---</p>
<h4 id="c-payout-diferido-com-meta-dispute">C) Payout Diferido com Meta-Dispute</h4>
<p><strong>Problema</strong>: Mesmo com commit-reveal, suborno pode acontecer antes do commit.</p>
<strong>SoluÃ§Ã£o</strong>:</code></pre>rust
<p>// ApÃ³s ruling, recompensas de jurors ficam time-locked</p>
<p>fn finalize_dispute(order_id: OrderId) {</p>
<p>    let ruling = calculate_ruling(order_id)?;</p>
<p>    apply_ruling(order_id, ruling);</p>
<p>    // Recompensas travadas por 7 dias</p>
<p>    for juror in Disputes::get(order_id).jurors {</p>
<p>        JurorPayouts::insert(juror, Payout {</p>
<p>            amount: calculate_reward(juror, ruling),</p>
<p>            unlock_at: now() + 7 * DAYS</p>
<p>        });</p>
<p>    }</p>
<p>    // Janela para Meta-Dispute</p>
<p>    MetaDisputeWindow::insert(order_id, now() + 7 * DAYS);</p>
<p>}</p>
<p>// Qualquer parte pode abrir Meta-Dispute se apresentar prova de colusÃ£o</p>
<p>fn open_meta_dispute(</p>
<p>    origin,</p>
<p>    order_id: OrderId,</p>
<p>    evidence_of_collusion: Vec<u8>  // ex.: mensagens de chat vazadas</p>
<p>) {</p>
<p>    ensure!(now() < MetaDisputeWindow::get(order_id), "Window closed");</p>
<p>    // Nova rodada com jurors diferentes</p>
<p>    // Se procedente: slashing dos jurors originais + ban</p>
<p>}</p>
<pre><code class="language-">
<p>---</p>
<h4 id="d-multi-rodadas-com-custo-crescente-escada-de-apelacao">D) Multi-Rodadas com Custo Crescente (Escada de ApelaÃ§Ã£o)</h4>
<p><strong>Problema</strong>: Parte perdedora pode tentar subornar jÃºri de apelaÃ§Ã£o.</p>
<strong>SoluÃ§Ã£o</strong>:</code></pre>rust
<p>struct DisputeLevel {</p>
<p>    level: u8,           // 1, 2, 3</p>
<p>    juror_count: u32,    // 7, 21, 63</p>
<p>    stake_required: Balance,  // 10 BZR, 50 BZR, 200 BZR</p>
<p>}</p>
<p>// Primeira rodada: 7 jurors</p>
<p>// ApelaÃ§Ã£o nÃ­vel 1: 21 jurors (3x mais) + stake 5x maior</p>
<p>// ApelaÃ§Ã£o nÃ­vel 2: 63 jurors (9x mais) + stake 20x maior</p>
<p>// Custo de subornar cresce geometricamente</p>
<p>// Atacante precisaria corromper maioria de 63 jurors com 200 BZR cada</p>
<p>// = 126.000 BZR de risco para reverter decisÃ£o</p>
<pre><code class="language-">
<p>---</p>
<h4 id="e-amostragem-estratificada">E) Amostragem Estratificada</h4>
<p><strong>Problema</strong>: Jurors de mesma regiÃ£o/grupo podem ter viÃ©s ou coordenar.</p>
<strong>SoluÃ§Ã£o</strong>:</code></pre>rust
<p>// Seleciona jurors de diferentes shards geogrÃ¡ficos/demogrÃ¡ficos</p>
<p>fn select_stratified_jurors(pool: Vec<AccountId>, count: u32) -> Vec<AccountId> {</p>
<p>    let shards = stratify_by_geo_and_reputation(pool);</p>
<p>    let per_shard = count / shards.len();</p>
<p>    let mut selected = Vec::new();</p>
<p>    for shard in shards {</p>
<p>        selected.extend(</p>
<p>            select_random_subset(shard, per_shard, random_seed())</p>
<p>        );</p>
<p>    }</p>
<p>    selected</p>
<p>}</p>
<pre><code class="language-">
<p>---</p>
<h3 id="133-qualidade-das-evidencias">13.3 Qualidade das EvidÃªncias</h3>
<h4 id="a-padroes-de-captura-obrigatorios">A) PadrÃµes de Captura ObrigatÃ³rios</h4>
<p><strong>App forÃ§a</strong>:</p>
<li>Watermark com order_id, timestamp, signatÃ¡rio</li>
<li>QR code efÃªmero para validaÃ§Ã£o cruzada</li>
<li>Device attestation (SafetyNet/Play Integrity)</li>
</code></pre>json
<p>{</p>
<p>  "media_cid": "QmPhoto",</p>
<p>  "watermark": {</p>
<p>    "order_id": "0xABC",</p>
<p>    "timestamp": "2025-10-28T14:00:00Z",</p>
<p>    "captured_by": "5Courier...",</p>
<p>    "qr_nonce": "xyz123"</p>
<p>  },</p>
<p>  "device_attestation": {</p>
<p>    "platform": "Android",</p>
<p>    "integrity_token": "eyJhbGc...",</p>
<p>    "verdict": "MEETS_DEVICE_INTEGRITY"</p>
<p>  }</p>
<p>}</p>
<pre><code class="language-">
<p>---</p>
<h4 id="b-provas-de-localizacao-robustas">B) Provas de LocalizaÃ§Ã£o Robustas</h4>
<strong>Multi-sensor fusion</strong>:</code></pre>rust
<p>struct LocationProof {</p>
<p>    gps: Coordinates,</p>
<p>    wifi_bssids: Vec<String>,      // roteadores detectados</p>
<p>    cell_tower_ids: Vec<u32>,      // torres de celular</p>
<p>    bluetooth_beacons: Vec<String>, // beacons BLE</p>
<p>    accuracy_meters: f64,</p>
<p>    timestamp: u64</p>
<p>}</p>
<p>// ValidaÃ§Ã£o cruzada: todos os sensores devem concordar com mesma regiÃ£o</p>
<p>fn validate_location(proof: LocationProof, expected_region: Region) -> bool {</p>
<p>    gps_matches(proof.gps, expected_region)</p>
<p>    && wifi_matches(proof.wifi_bssids, expected_region)</p>
<p>    && cell_matches(proof.cell_tower_ids, expected_region)</p>
<p>}</p>
<pre><code class="language-">
<strong>Fase 3: ZK-PoD</strong></code></pre>
<p>Courier prova:</p>
<p>  "Eu estava em um raio de 500m do endereÃ§o X no horÃ¡rio Y"</p>
<p>  SEM revelar coordenadas exatas</p>
<p>Via Zero-Knowledge Proof verificÃ¡vel on-chain</p>
<pre><code class="language-">
<p>---</p>
<h4 id="c-bundles-probatorios-versionados">C) Bundles ProbatÃ³rios Versionados</h4>
<strong>Schema de evidÃªncia</strong>:</code></pre>json
<p>{</p>
<p>  "version": "1.2.0",</p>
<p>  "required_fields": [</p>
<p>    "handoff_photo_with_seal",</p>
<p>    "delivery_photo_with_recipient",</p>
<p>    "geo_proof",</p>
<p>    "timestamps"</p>
<p>  ],</p>
<p>  "optional_fields": [</p>
<p>    "video_sequence",</p>
<p>    "witness_signature"</p>
<p>  ],</p>
<p>  "fraud_indicators": [</p>
<p>    "timestamp_manipulation",</p>
<p>    "geo_spoofing",</p>
<p>    "photoshop_detection"</p>
<p>  ]</p>
<p>}</p>
<pre><code class="language-">
<strong>Jurors recebem checklist</strong>:</code></pre>
<p>âœ… Foto do lacre presente?</p>
<p>âœ… Timestamp coerente com handoff anterior?</p>
<p>âœ… Geo dentro da tolerÃ¢ncia?</p>
<p>âš ï¸ Foto mostra sinais de ediÃ§Ã£o?</p>
<pre><code class="language-">
<p>---</p>
<h4 id="d-pre-scoring-automatico">D) Pre-Scoring AutomÃ¡tico</h4>
<p><strong>Fase 3: IA Assistiva</strong></p>
</code></pre>rust
<p>struct PreScore {</p>
<p>    overall: u8,  // 0-100</p>
<p>    confidence: f64,</p>
<p>    breakdown: {</p>
<p>        timestamp_validity: u8,</p>
<p>        geo_consistency: u8,</p>
<p>        media_authenticity: u8,</p>
<p>        signature_validity: u8</p>
<p>    },</p>
<p>    red_flags: Vec<String>,  // ex.: ["GPS jump detected", "Seal number mismatch"]</p>
<p>    explanation: String  // "Delivery proof is strong: all sensors agree, media unedited"</p>
<p>}</p>
<p>// Jurors veem o pre-score, mas mantÃªm decisÃ£o final</p>
<pre><code class="language-">
<p><strong>Treinamento da IA</strong>:</p>
<li>Dataset pÃºblico de disputas resolvidas</li>
<li>Labels: rulings finais + justificativas</li>
<li>Modelo: Explicabilidade obrigatÃ³ria (LIME/SHAP)</li>
<p>---</p>
<h4 id="e-auditoria-publica">E) Auditoria PÃºblica</h4>
<strong>Todo ruling grava</strong>:</code></pre>rust
<p>struct RulingRecord {</p>
<p>    order_id: OrderId,</p>
<p>    ruling: Ruling,</p>
<p>    jurors: Vec<AccountId>,  // anonimizados por hash, mas rastreÃ¡veis por DAO</p>
<p>    evidence_hashes: Vec<H256>,</p>
<p>    votes: Vec<(VoteHash, Vote)>,  // commit/reveal preservados</p>
<p>    pre_score: PreScore,</p>
<p>    timestamp: BlockNumber</p>
<p>}</p>
<p>// Qualquer um pode auditar:</p>
<p>// - CoerÃªncia de rulings similares</p>
<p>// - Taxa de acerto de jurors individuais</p>
<p>// - Desvios do pre-score (jurors ignoraram IA?)</p>
<pre><code class="language-">
<p>---</p>
<h3 id="134-parametros-de-seguranca">13.4 ParÃ¢metros de SeguranÃ§a</h3>
<p><strong>ConfiguraÃ§Ã£o Recomendada (Fase 2)</strong>:</p>
</code></pre>rust
<p>struct DisputeConfig {</p>
<p>    // Stakes</p>
<p>    stake_juror_min: Balance = 100 BZR,</p>
<p>    stake_juror_percent_of_order: f64 = 0.1,  // 10% do valor do pedido</p>
<p>    // Slashing</p>
<p>    slashing_wrong_vote: f64 = 0.3,  // 30% do stake</p>
<p>    slashing_no_show: f64 = 0.5,     // 50% do stake</p>
<p>    slashing_collusion: f64 = 1.0,   // 100% do stake + ban</p>
<p>    // QuÃ³runs</p>
<p>    jurors_first_level: u32 = 7,</p>
<p>    jurors_appeal_level1: u32 = 21,</p>
<p>    jurors_appeal_level2: u32 = 63,</p>
<p>    supermajority_threshold: f64 = 0.66,  // 2/3</p>
<p>    // Timeouts</p>
<p>    commit_window: BlockNumber = 24 * HOURS,</p>
<p>    reveal_window: BlockNumber = 24 * HOURS,</p>
<p>    payout_lock: BlockNumber = 7 * DAYS,</p>
<p>    meta_dispute_window: BlockNumber = 7 * DAYS,</p>
<p>    // ApelaÃ§Ãµes</p>
<p>    max_appeals: u8 = 2,</p>
<p>    appeal_stake_multiplier: f64 = 5.0,  // 5x o stake do nÃ­vel anterior</p>
<p>}</p>
<pre><code class="language-">
<p>---</p>
<h3 id="135-conclusao-disputas-como-ultima-linha">13.5 ConclusÃ£o: Disputas como Ãšltima Linha</h3>
<p><strong>Defesa em Profundidade</strong>:</p>
</code></pre>
<p>Camada 1: QuÃ³rum PoC (95% dos casos)</p>
<p>    â†“ falha</p>
<p>Camada 2: Timeouts + evidÃªncia automÃ¡tica</p>
<p>    â†“ falha</p>
<p>Camada 3: Dispute com 7 jurors + VRF + commit-reveal</p>
<p>    â†“ apelaÃ§Ã£o</p>
<p>Camada 4: 21 jurors + custo 5x maior</p>
<p>    â†“ apelaÃ§Ã£o final</p>
<p>Camada 5: 63 jurors + IA assistiva + DAO oversight</p>
</code>``
<p><strong>Custo de Ataque</strong>:</p>
<li>Subornar maioria de 7 jurors: ~500 BZR (arriscado)</li>
<li>Subornar maioria de 21 jurors: ~2.500 BZR + risco de meta-dispute</li>
<li>Subornar maioria de 63 jurors: ~12.000 BZR + alta probabilidade de detecÃ§Ã£o + ban permanente</li>
<p><strong>Para a maioria dos pedidos (< 500 BZR)</strong>: custo de ataque > valor do pedido â†’ economicamente irracional.</p>
<p>---</p>
<h2 id="proximos-documentos">PrÃ³ximos Documentos</h2>
<li><strong><a href="./03-dores-mercado.html">03-dores-mercado.html</a></strong>: AnÃ¡lise das dores do mercado tradicional e como Bazari resolve</li>
<li><strong><a href="./04-modulos-ecossistema.html">04-modulos-ecossistema.html</a></strong>: DescriÃ§Ã£o completa de cada mÃ³dulo do ecossistema</li>
<li><strong><a href="./05-arquitetura.html">05-arquitetura.html</a></strong>: Arquitetura tÃ©cnica detalhada e pallets Substrate</li>
<li><strong><a href="./06-roadmap.html">06-roadmap.html</a></strong>: Roadmap de 3 fases e evoluÃ§Ã£o futura (ZK-PoD, BLS, IA)</li></ul>
<p>---</p>
<p><strong>Bazari Proof of Commerce</strong> â€” ConfianÃ§a substituÃ­da por matemÃ¡tica, trabalho verificado por criptografia.</p>

      <!-- Navigation -->
      <div class="doc-navigation">
        <a href="01-visao-geral.html" class="prev">â† Anterior</a>
        <a href="03-dores-mercado.html" class="next">PrÃ³ximo â†’</a>
      </div>
    </main>
  </div>

  <script src="../assets/script.v2.js"></script>
</body>
</html>