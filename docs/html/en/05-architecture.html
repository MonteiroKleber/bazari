<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Architecture and Technical Implementation - Bazari Documentation">
  <title>Architecture and Technical Implementation | Bazari Docs</title>
  <link rel="stylesheet" href="../assets/style.v2.css">
  <link rel="stylesheet" href="../assets/prism.v2.css">
</head>
<body>
  <div class="doc-container">
    <!-- Header -->
    <header class="doc-header">
      <h1><span class="logo">ğŸª</span> Bazari Docs</h1>
      <div class="doc-controls">
        <nav class="lang-switcher">
          <button data-lang="pt">ğŸ‡§ğŸ‡· PT</button>
          <button data-lang="en" class="active">ğŸ‡ºğŸ‡¸ EN</button>
          </nav>
        <button class="theme-toggle">ğŸŒ™</button>
      </div>
    </header>

    <!-- Sidebar -->
    <aside class="doc-sidebar">
      <h2 id="documentation">ğŸ“š Documentation</h2>
      <nav class="doc-nav">
        <ul>
          <li><a href="index.html">ğŸ  Home</a></li>
          <li><a href="01-overview-context.html" >01. Overview and Context</a></li>
          <li><a href="02-proof-of-commerce.html" >02. Proof of Commerce - Technical Specification</a></li>
          <li><a href="03-market-pain-points.html" >03. Market Pain Points and Bazari Solutions</a></li>
          <li><a href="04-ecosystem-modules.html" >04. Bazari Ecosystem Modules</a></li>
          <li><a href="05-architecture.html" class="active">05. Architecture and Technical Implementation</a></li>
          <li><a href="06-roadmap.html" >06. Roadmap and Future Evolution</a></li>
        </ul>
      </nav>
    </aside>

    <!-- Main Content -->
    <main class="doc-main">
      <h2 id="05-technical-architecture-and-implementation">05. Technical Architecture and Implementation</h2>
<p>---</p>
<h2 id="table-of-contents">Table of Contents</h2>
<p>1. <a href="#1-technology-stack">Technology Stack</a></p>
<p>2. <a href="#2-layered-architecture">Layered Architecture</a></p>
<p>3. <a href="#3-detailed-substrate-pallets">Detailed Substrate Pallets</a></p>
<p>4. <a href="#4-schemas-and-data-structures">Schemas and Data Structures</a></p>
<p>5. <a href="#5-data-flows">Data Flows</a></p>
<p>6. <a href="#6-infrastructure-and-deployment">Infrastructure and Deployment</a></p>
<p>7. <a href="#7-security-and-auditing">Security and Auditing</a></p>
<p>---</p>
<h2 id="1-technology-stack">1. Technology Stack</h2>
<h3 id="11-blockchain-layer">1.1 Blockchain Layer</h3>
<p>| Component | Technology | Justification |</p>
<p>|------------|-----------|---------------|</p>
<p>| <strong>Blockchain Framework</strong> | Substrate (Rust) | Modularity, performance, Polkadot interoperability |</p>
<p>| <strong>Consensus</strong> | GRANDPA + BABE | Fast finality (~12s), proven security |</p>
<p>| <strong>Smart Contracts</strong> | Native Pallets (not ink!) | Better performance and integration |</p>
<p>| <strong>Storage</strong> | RocksDB | Optimized for key-value, used by Substrate |</p>
<h3 id="12-application-layer">1.2 Application Layer</h3>
<p>| Component | Technology | Justification |</p>
<p>|------------|-----------|---------------|</p>
<p>| <strong>Frontend Web</strong> | Next.js + React + TypeScript | SSR, performance, type safety |</p>
<p>| <strong>Mobile</strong> | React Native + Expo | Code sharing, rapid prototyping |</p>
<p>| <strong>Desktop</strong> | Tauri (Rust + Web) | Lightweight, secure, cross-platform |</p>
<p>| <strong>State Management</strong> | Zustand / Jotai | Simple, performant, TypeScript-first |</p>
<p>| <strong>Blockchain Client</strong> | Polkadot.js API | Substrate ecosystem standard |</p>
<h3 id="13-infrastructure-layer">1.3 Infrastructure Layer</h3>
<p>| Component | Technology | Justification |</p>
<p>|------------|-----------|---------------|</p>
<p>| <strong>P2P Messaging</strong> | libp2p + gossipsub | Polkadot standard, battle-tested |</p>
<p>| <strong>File Storage</strong> | IPFS + Filecoin | Decentralized, immutable, incentivized |</p>
<p>| <strong>Indexing</strong> | SubQuery / The Graph | Fast on-chain data queries |</p>
<p>| <strong>Off-Chain Database</strong> | PostgreSQL + Redis | Caching, analytics, full-text search |</p>
<p>| <strong>API Gateway</strong> | GraphQL (Apollo) | Flexible queries, intelligent cache |</p>
<p>---</p>
<h2 id="2-layered-architecture">2. Layered Architecture</h2>
<pre><code class="language-">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
<p>â”‚                     LAYER 1: USER INTERFACE                     â”‚</p>
<p>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</p>
<p>â”‚  Web App (Next.js)  â”‚  Mobile (RN)  â”‚  Desktop (Tauri)         â”‚</p>
<p>â”‚  â€¢ Marketplace UI   â”‚  â€¢ BazChat    â”‚  â€¢ Full Node            â”‚</p>
<p>â”‚  â€¢ DAO Dashboard    â”‚  â€¢ Wallet     â”‚  â€¢ Dev Tools            â”‚</p>
<p>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</p>
<p>                            â”‚</p>
<p>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</p>
<p>â”‚                  LAYER 2: APPLICATION SERVICES                  â”‚</p>
<p>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</p>
<p>â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚</p>
<p>â”‚  â”‚  GraphQL   â”‚  â”‚  SubQuery  â”‚  â”‚   IPFS     â”‚               â”‚</p>
<p>â”‚  â”‚   API      â”‚  â”‚  Indexer   â”‚  â”‚  Gateway   â”‚               â”‚</p>
<p>â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜               â”‚</p>
<p>â”‚        â”‚                â”‚                â”‚                      â”‚</p>
<p>â”‚  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”              â”‚</p>
<p>â”‚  â”‚         PostgreSQL + Redis Cache             â”‚              â”‚</p>
<p>â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚</p>
<p>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</p>
<p>                          â”‚</p>
<p>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</p>
<p>â”‚                  LAYER 3: BLOCKCHAIN RUNTIME                   â”‚</p>
<p>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</p>
<p>â”‚                    BazariChain (Substrate)                      â”‚</p>
<p>â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚</p>
<p>â”‚  â”‚  Pallets:                                                 â”‚ â”‚</p>
<p>â”‚  â”‚  â€¢ pallet-order       â€¢ pallet-escrow                     â”‚ â”‚</p>
<p>â”‚  â”‚  â€¢ pallet-attestation â€¢ pallet-fulfillment                â”‚ â”‚</p>
<p>â”‚  â”‚  â€¢ pallet-affiliate   â€¢ pallet-reputation                 â”‚ â”‚</p>
<p>â”‚  â”‚  â€¢ pallet-dispute     â€¢ pallet-dao                        â”‚ â”‚</p>
<p>â”‚  â”‚  â€¢ pallet-p2p         â€¢ pallet-fee                        â”‚ â”‚</p>
<p>â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚</p>
<p>â”‚                                                                 â”‚</p>
<p>â”‚  Runtime APIs: RPC, WebSocket, Offchain Workers                â”‚</p>
<p>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</p>
<p>                            â”‚</p>
<p>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</p>
<p>â”‚                LAYER 4: CONSENSUS & NETWORKING                  â”‚</p>
<p>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</p>
<p>â”‚  GRANDPA (finality) + BABE (block production)                   â”‚</p>
<p>â”‚  libp2p (peer discovery, gossip, sync)                          â”‚</p>
<p>â”‚  RocksDB (persistent storage)                                   â”‚</p>
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
<p>---</p>
<h2 id="3-detailed-substrate-pallets">3. Detailed Substrate Pallets</h2>
<h3 id="31-pallet-order">3.1 pallet-order</h3>
<p><strong>Responsibility</strong>: Complete order lifecycle.</p>
<pre><code class="language-rust">// Storage
<p>#[pallet::storage]</p>
<p>pub type Orders<T: Config> = StorageMap<</p>
<p>    _,</p>
<p>    Blake2_128Concat,</p>
<p>    OrderId,</p>
<p>    OrderData<T::AccountId, T::BlockNumber, BalanceOf<T>>,</p>
<p>>;</p>
<p>#[pallet::storage]</p>
<p>pub type OrderHistory<T: Config> = StorageMap<</p>
<p>    _,</p>
<p>    Blake2_128Concat,</p>
<p>    OrderId,</p>
<p>    BoundedVec<StateTransition<T::BlockNumber>, T::MaxHistoryEntries>,</p>
<p>>;</p>
<p>// Structures</p>
<p>pub struct OrderData<AccountId, BlockNumber, Balance> {</p>
<p>    pub buyer: AccountId,</p>
<p>    pub seller: AccountId,</p>
<p>    pub courier: Option<AccountId>,</p>
<p>    pub product_id: ProductId,</p>
<p>    pub quantity: u32,</p>
<p>    pub price: Balance,</p>
<p>    pub escrow_amount: Balance,</p>
<p>    pub status: OrderStatus,</p>
<p>    pub created_at: BlockNumber,</p>
<p>    pub updated_at: BlockNumber,</p>
<p>    pub affiliate_path: Option<AffiliatePath>,</p>
<p>}</p>
<p>pub enum OrderStatus {</p>
<p>    Created,</p>
<p>    Accepted,</p>
<p>    CourierAssigned,</p>
<p>    HandoffCompleted,</p>
<p>    InTransit,</p>
<p>    Delivered,</p>
<p>    Finalized,</p>
<p>    Disputed,</p>
<p>    Cancelled,</p>
<p>}</p>
<p>// Main extrinsics</p>
<p>#[pallet::call]</p>
<p>impl<T: Config> Pallet<T> {</p>
<p>    #[pallet::weight(10_000)]</p>
<p>    pub fn create_order(</p>
<p>        origin: OriginFor<T>,</p>
<p>        seller: T::AccountId,</p>
<p>        product_id: ProductId,</p>
<p>        quantity: u32,</p>
<p>        escrow_amount: BalanceOf<T>,</p>
<p>        affiliate_path: Option<AffiliatePath>,</p>
<p>    ) -> DispatchResult {</p>
<p>        let buyer = ensure_signed(origin)?;</p>
<p>        // Validate product exists</p>
<p>        ensure!(</p>
<p>            pallet_product::Products::<T>::contains_key(product_id),</p>
<p>            Error::<T>::ProductNotFound</p>
<p>        );</p>
<p>        // Create order</p>
<p>        let order_id = Self::next_order_id();</p>
<p>        let order = OrderData {</p>
<p>            buyer: buyer.clone(),</p>
<p>            seller: seller.clone(),</p>
<p>            courier: None,</p>
<p>            product_id,</p>
<p>            quantity,</p>
<p>            price: escrow_amount,</p>
<p>            escrow_amount,</p>
<p>            status: OrderStatus::Created,</p>
<p>            created_at: <frame_system::Pallet<T>>::block_number(),</p>
<p>            updated_at: <frame_system::Pallet<T>>::block_number(),</p>
<p>            affiliate_path,</p>
<p>        };</p>
<p>        Orders::<T>::insert(order_id, order);</p>
<p>        // Deposit escrow</p>
<p>        pallet_escrow::Pallet::<T>::deposit(buyer.clone(), order_id, escrow_amount)?;</p>
<p>        // Event</p>
<p>        Self::deposit_event(Event::OrderCreated {</p>
<p>            order_id,</p>
<p>            buyer,</p>
<p>            seller,</p>
<p>            amount: escrow_amount,</p>
<p>        });</p>
<p>        Ok(())</p>
<p>    }</p>
<p>    #[pallet::weight(5_000)]</p>
<p>    pub fn accept_order(</p>
<p>        origin: OriginFor<T>,</p>
<p>        order_id: OrderId,</p>
<p>    ) -> DispatchResult {</p>
<p>        let seller = ensure_signed(origin)?;</p>
<p>        Orders::<T>::try_mutate(order_id, |maybe_order| {</p>
<p>            let order = maybe_order.as_mut().ok_or(Error::<T>::OrderNotFound)?;</p>
<p>            ensure!(order.seller == seller, Error::<T>::NotSeller);</p>
<p>            ensure!(order.status == OrderStatus::Created, Error::<T>::InvalidStatus);</p>
<p>            order.status = OrderStatus::Accepted;</p>
<p>            order.updated_at = <frame_system::Pallet<T>>::block_number();</p>
<p>            Self::deposit_event(Event::OrderAccepted { order_id, seller });</p>
<p>            Ok(())</p>
<p>        })</p>
<p>    }</p>
<p>    #[pallet::weight(20_000)]</p>
<p>    pub fn finalize(</p>
<p>        origin: OriginFor<T>,</p>
<p>        order_id: OrderId,</p>
<p>    ) -> DispatchResult {</p>
<p>        ensure_signed(origin)?; // Can be called by anyone (permissionless)</p>
<p>        let order = Orders::<T>::get(order_id).ok_or(Error::<T>::OrderNotFound)?;</p>
<p>        ensure!(order.status == OrderStatus::Delivered, Error::<T>::InvalidStatus);</p>
<p>        // Validate PoC quorum</p>
<p>        pallet_attestation::Pallet::<T>::validate_quorum(order_id)?;</p>
<p>        // Split escrow</p>
<p>        pallet_escrow::Pallet::<T>::split(</p>
<p>            order_id,</p>
<p>            &order.seller,</p>
<p>            &order.courier.unwrap(),</p>
<p>            order.affiliate_path.as_ref(),</p>
<p>        )?;</p>
<p>        // Update reputations</p>
<p>        pallet_reputation::Pallet::<T>::increment_seller_score(&order.seller, 10)?;</p>
<p>        pallet_reputation::Pallet::<T>::increment_courier_score(&order.courier.unwrap(), 10)?;</p>
<p>        // Update status</p>
<p>        Orders::<T>::mutate(order_id, |maybe_order| {</p>
<p>            if let Some(order) = maybe_order {</p>
<p>                order.status = OrderStatus::Finalized;</p>
<p>                order.updated_at = <frame_system::Pallet<T>>::block_number();</p>
<p>            }</p>
<p>        });</p>
<p>        Self::deposit_event(Event::OrderFinalized { order_id });</p>
<p>        Ok(())</p>
<p>    }</p>
}</code></pre>
<p>---</p>
<h3 id="32-pallet-escrow">3.2 pallet-escrow</h3>
<p><strong>Responsibility</strong>: Manage locked funds until finalization.</p>
<pre><code class="language-rust">#[pallet::storage]
<p>pub type Locks<T: Config> = StorageMap<</p>
<p>    _,</p>
<p>    Blake2_128Concat,</p>
<p>    OrderId,</p>
<p>    BalanceOf<T>,</p>
<p>>;</p>
<p>#[pallet::storage]</p>
<p>pub type Releases<T: Config> = StorageMap<</p>
<p>    _,</p>
<p>    Blake2_128Concat,</p>
<p>    OrderId,</p>
<p>    BoundedVec<(T::AccountId, BalanceOf<T>), T::MaxSplits>,</p>
<p>>;</p>
<p>#[pallet::call]</p>
<p>impl<T: Config> Pallet<T> {</p>
<p>    pub fn deposit(</p>
<p>        depositor: T::AccountId,</p>
<p>        order_id: OrderId,</p>
<p>        amount: BalanceOf<T>,</p>
<p>    ) -> DispatchResult {</p>
<p>        // Transfer from depositor to pallet account (reserve)</p>
<p>        <pallet_balances::Pallet<T> as ReservableCurrency<_>>::reserve(</p>
<p>            &depositor,</p>
<p>            amount,</p>
<p>        )?;</p>
<p>        Locks::<T>::insert(order_id, amount);</p>
<p>        Self::deposit_event(Event::EscrowDeposited { order_id, depositor, amount });</p>
<p>        Ok(())</p>
<p>    }</p>
<p>    pub fn split(</p>
<p>        order_id: OrderId,</p>
<p>        seller: &T::AccountId,</p>
<p>        courier: &T::AccountId,</p>
<p>        affiliate_path: Option<&AffiliatePath>,</p>
<p>    ) -> DispatchResult {</p>
<p>        let escrow_amount = Locks::<T>::get(order_id).ok_or(Error::<T>::NoEscrow)?;</p>
<p>        let mut releases = BoundedVec::new();</p>
<p>        let mut remaining = escrow_amount;</p>
<p>        // Calculate fees</p>
<p>        let fee_config = pallet_fee::Pallet::<T>::config();</p>
<p>        let dao_fee = escrow_amount * fee_config.dao_fee_percent / 10000;</p>
<p>        let treasury_fee = escrow_amount * fee_config.treasury_percent / 10000;</p>
<p>        // Calculate affiliate commissions</p>
<p>        let affiliate_total = if let Some(path) = affiliate_path {</p>
<p>            pallet_affiliate::Pallet::<T>::calculate_splits(order_id, path)?</p>
<p>        } else {</p>
<p>            0u32.into()</p>
<p>        };</p>
<p>        remaining = remaining</p>
<p>            .saturating_sub(dao_fee)</p>
<p>            .saturating_sub(treasury_fee)</p>
<p>            .saturating_sub(affiliate_total);</p>
<p>        // Main split (after deducting everything)</p>
<p>        let order = pallet_order::Orders::<T>::get(order_id).unwrap();</p>
<p>        let frete = order.frete_amount; // assuming this exists</p>
<p>        let seller_amount = remaining.saturating_sub(frete);</p>
<p>        releases.try_push((seller.clone(), seller_amount)).ok();</p>
<p>        releases.try_push((courier.clone(), frete)).ok();</p>
<p>        Releases::<T>::insert(order_id, releases.clone());</p>
<p>        // Execute transfers</p>
<p>        for (recipient, amount) in releases.iter() {</p>
<p>            <pallet_balances::Pallet<T> as ReservableCurrency<_>>::unreserve(</p>
<p>                recipient,</p>
<p>                *amount,</p>
<p>            );</p>
<p>        }</p>
<p>        // Remove lock</p>
<p>        Locks::<T>::remove(order_id);</p>
<p>        Self::deposit_event(Event::EscrowSplit { order_id });</p>
<p>        Ok(())</p>
<p>    }</p>
}</code></pre>
<p>---</p>
<h3 id="33-pallet-attestation">3.3 pallet-attestation</h3>
<p><strong>Responsibility</strong>: Anchor proofs (hashes) and validate signers.</p>
<pre><code class="language-rust">#[pallet::storage]
<p>pub type Attestations<T: Config> = StorageDoubleMap<</p>
<p>    _,</p>
<p>    Blake2_128Concat, OrderId,</p>
<p>    Blake2_128Concat, OrderStep,</p>
<p>    AttestationData<T::AccountId, T::BlockNumber>,</p>
<p>>;</p>
<p>pub struct AttestationData<AccountId, BlockNumber> {</p>
<p>    pub payload_hash: H256,</p>
<p>    pub signers: Vec<(AccountId, Signature)>,</p>
<p>    pub timestamp: BlockNumber,</p>
<p>    pub metadata: BoundedVec<u8, ConstU32<256>>,</p>
<p>}</p>
<p>#[pallet::call]</p>
<p>impl<T: Config> Pallet<T> {</p>
<p>    #[pallet::weight(15_000)]</p>
<p>    pub fn submit_attestation(</p>
<p>        origin: OriginFor<T>,</p>
<p>        order_id: OrderId,</p>
<p>        step: OrderStep,</p>
<p>        payload_hash: H256,</p>
<p>        signatures: Vec<(T::AccountId, Signature)>,</p>
<p>        metadata: Option<Vec<u8>>,</p>
<p>    ) -> DispatchResult {</p>
<p>        let submitter = ensure_signed(origin)?;</p>
<p>        // Validate submitter is one of the signers</p>
<p>        ensure!(</p>
<p>            signatures.iter().any(|(acc, _)| acc == &submitter),</p>
<p>            Error::<T>::NotASigner</p>
<p>        );</p>
<p>        // Validate signatures</p>
<p>        for (account, sig) in &signatures {</p>
<p>            Self::verify_signature(account, &payload_hash, sig)?;</p>
<p>        }</p>
<p>        // Validate correct signers for step</p>
<p>        Self::validate_signers_for_step(order_id, &step, &signatures)?;</p>
<p>        // Anchor</p>
<p>        let attestation = AttestationData {</p>
<p>            payload_hash,</p>
<p>            signers: signatures,</p>
<p>            timestamp: <frame_system::Pallet<T>>::block_number(),</p>
<p>            metadata: metadata.unwrap_or_default().try_into().unwrap_or_default(),</p>
<p>        };</p>
<p>        Attestations::<T>::insert(order_id, step, attestation);</p>
<p>        // Update order status</p>
<p>        Self::update_order_status(order_id, step)?;</p>
<p>        Self::deposit_event(Event::AttestationSubmitted { order_id, step, payload_hash });</p>
<p>        Ok(())</p>
<p>    }</p>
<p>    pub fn validate_quorum(order_id: OrderId) -> DispatchResult {</p>
<p>        // Validate required attestations exist</p>
<p>        ensure!(</p>
<p>            Attestations::<T>::contains_key(order_id, OrderStep::HandoffSellerToCourier),</p>
<p>            Error::<T>::MissingHandoffProof</p>
<p>        );</p>
<p>        ensure!(</p>
<p>            Attestations::<T>::contains_key(order_id, OrderStep::DeliveredCourierToBuyer),</p>
<p>            Error::<T>::MissingDeliveryProof</p>
<p>        );</p>
<p>        // Validate correct signers</p>
<p>        let handoff = Attestations::<T>::get(order_id, OrderStep::HandoffSellerToCourier).unwrap();</p>
<p>        let delivery = Attestations::<T>::get(order_id, OrderStep::DeliveredCourierToBuyer).unwrap();</p>
<p>        let order = pallet_order::Orders::<T>::get(order_id).unwrap();</p>
<p>        // Handoff must have Seller + Courier</p>
<p>        ensure!(</p>
<p>            handoff.signers.iter().any(|(acc, _)| acc == &order.seller),</p>
<p>            Error::<T>::SellerNotSignedHandoff</p>
<p>        );</p>
<p>        ensure!(</p>
<p>            handoff.signers.iter().any(|(acc, _)| acc == &order.courier.unwrap()),</p>
<p>            Error::<T>::CourierNotSignedHandoff</p>
<p>        );</p>
<p>        // Delivery must have Courier + Buyer</p>
<p>        ensure!(</p>
<p>            delivery.signers.iter().any(|(acc, _)| acc == &order.courier.unwrap()),</p>
<p>            Error::<T>::CourierNotSignedDelivery</p>
<p>        );</p>
<p>        ensure!(</p>
<p>            delivery.signers.iter().any(|(acc, _)| acc == &order.buyer),</p>
<p>            Error::<T>::BuyerNotSignedDelivery</p>
<p>        );</p>
<p>        Ok(())</p>
<p>    }</p>
}</code></pre>
<p>---</p>
<h2 id="4-schemas-and-data-structures">4. Schemas and Data Structures</h2>
<h3 id="41-handoffproof-json-off-chain">4.1 HandoffProof JSON (Off-Chain)</h3>
<pre><code class="language-json">{
<p>  "version": "1.0.0",</p>
<p>  "order_id": "0x1a2b3c4d5e6f7890abcdef1234567890",</p>
<p>  "step": "HANDOFF_SELLER_TO_COURIER",</p>
<p>  "timestamp": "2025-10-28T10:15:00.000Z",</p>
<p>  "geo": {</p>
<p>    "lat": -23.550520,</p>
<p>    "lon": -46.633308,</p>
<p>    "accuracy_meters": 5,</p>
<p>    "provider": "gps"</p>
<p>  },</p>
<p>  "media": [</p>
<p>    {</p>
<p>      "type": "photo",</p>
<p>      "cid": "QmHandoffPhoto123...",</p>
<p>      "description": "Pacote lacrado com nÃºmero de sÃ©rie visÃ­vel",</p>
<p>      "hash": "blake2b:0xabc..."</p>
<p>    }</p>
<p>  ],</p>
<p>  "product_condition": {</p>
<p>    "seal": "intact",</p>
<p>    "seal_number": "SEAL-12345",</p>
<p>    "weight_kg": 1.2,</p>
<p>    "dimensions_cm": [30, 20, 10],</p>
<p>    "notes": "Caixa em perfeito estado"</p>
<p>  },</p>
<p>  "device_attestation": {</p>
<p>    "platform": "iOS",</p>
<p>    "app_version": "1.2.3",</p>
<p>    "integrity_token": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9..."</p>
<p>  },</p>
<p>  "signers": [</p>
<p>    {</p>
<p>      "role": "Seller",</p>
<p>      "account_id": "5SellerABC123...",</p>
<p>      "signature": "0xabcdef1234567890...",</p>
<p>      "signature_method": "sr25519",</p>
<p>      "signed_at": "2025-10-28T10:15:05.000Z"</p>
<p>    },</p>
<p>    {</p>
<p>      "role": "Courier",</p>
<p>      "account_id": "5CourierDEF456...",</p>
<p>      "signature": "0x1234567890abcdef...",</p>
<p>      "signature_method": "sr25519",</p>
<p>      "signed_at": "2025-10-28T10:15:08.000Z"</p>
<p>    }</p>
<p>  ],</p>
<p>  "nonce": "random_nonce_xyz789",</p>
<p>  "schema_hash": "0x..."</p>
}</code></pre>
<p><strong>Hash Anchored On-Chain</strong>:</p>
<pre><code class="language-rust">let payload_hash = blake2_256(&json_bytes);
// Result: 0xabc123def456... (32 bytes)</code></pre>
<p>---</p>
<h3 id="42-affiliate-merkle-proof">4.2 Affiliate Merkle Proof</h3>
<pre><code class="language-json">{
<p>  "campaign_id": "0xCampaign123",</p>
<p>  "path": [</p>
<p>    {</p>
<p>      "account_id": "5Affiliate1...",</p>
<p>      "level": 1,</p>
<p>      "commission_rate": 0.025</p>
<p>    },</p>
<p>    {</p>
<p>      "account_id": "5Affiliate2...",</p>
<p>      "level": 2,</p>
<p>      "commission_rate": 0.0125</p>
<p>    }</p>
<p>  ],</p>
<p>  "merkle_proof": {</p>
<p>    "root": "0xRootHash...",</p>
<p>    "siblings": [</p>
<p>      "0xSibling1Hash...",</p>
<p>      "0xSibling2Hash..."</p>
<p>    ],</p>
<p>    "path_indices": [0, 1]</p>
<p>  }</p>
}</code></pre>
<p><strong>On-Chain Validation</strong>:</p>
<pre><code class="language-rust">fn verify_merkle_proof(
<p>    leaf: H256,</p>
<p>    root: H256,</p>
<p>    siblings: &[H256],</p>
<p>    path_indices: &[u8],</p>
<p>) -> bool {</p>
<p>    let mut computed_hash = leaf;</p>
<p>    for (sibling, &index) in siblings.iter().zip(path_indices) {</p>
<p>        computed_hash = if index == 0 {</p>
<p>            blake2_256(&[computed_hash.as_bytes(), sibling.as_bytes()].concat())</p>
<p>        } else {</p>
<p>            blake2_256(&[sibling.as_bytes(), computed_hash.as_bytes()].concat())</p>
<p>        };</p>
<p>    }</p>
<p>    computed_hash == root</p>
}</code></pre>
<p>---</p>
<h2 id="5-data-flows">5. Data Flows</h2>
<h3 id="51-order-creation-complete-sequence">5.1 Order Creation (Complete Sequence)</h3>
<pre><code class="language-mermaid">sequenceDiagram
<p>    participant User as Buyer (Frontend)</p>
<p>    participant Wallet</p>
<p>    participant API as GraphQL API</p>
<p>    participant Chain as BazariChain</p>
<p>    participant IPFS</p>
<p>    participant Indexer as SubQuery</p>
<p>    User->>Wallet: create_order()</p>
<p>    Wallet->>Wallet: Sign transaction</p>
<p>    Wallet->>Chain: submit extrinsic</p>
<p>    Chain->>Chain: Validate + execute</p>
<p>    Chain->>Chain: Deposit escrow</p>
<p>    Chain->>Chain: Emit OrderCreated event</p>
<p>    Chain-->>Wallet: TxHash + confirmation</p>
<p>    Wallet-->>User: "Order created!"</p>
<p>    Chain->>Indexer: Event via WebSocket</p>
<p>    Indexer->>Indexer: Process + save PostgreSQL</p>
<p>    User->>API: Query order (GraphQL)</p>
<p>    API->>Indexer: Fetch data</p>
<p>    Indexer-->>API: Return JSON</p>
    API-->>User: Display timeline</code></pre>
<p>---</p>
<h3 id="52-deliveryproof-co-signature">5.2 DeliveryProof Co-Signature</h3>
<pre><code class="language-mermaid">sequenceDiagram
<p>    participant Courier</p>
<p>    participant Buyer</p>
<p>    participant BazChat as BazChat (P2P)</p>
<p>    participant IPFS</p>
<p>    participant Chain as BazariChain</p>
<p>    Courier->>BazChat: Arrives at address</p>
<p>    BazChat->>BazChat: Open "Delivery" screen</p>
<p>    Courier->>BazChat: Take photo + location</p>
<p>    BazChat->>Buyer: Push notification</p>
<p>    Buyer->>BazChat: Open screen</p>
<p>    Buyer->>BazChat: Verify package + sign digitally</p>
<p>    BazChat->>BazChat: Generate JSON (payload)</p>
<p>    BazChat->>BazChat: Both sign locally</p>
<p>    BazChat->>IPFS: Upload media</p>
<p>    IPFS-->>BazChat: CID returned</p>
<p>    BazChat->>BazChat: Add CID to JSON</p>
<p>    BazChat->>BazChat: Calculate payload_hash</p>
<p>    Courier->>Chain: submit_attestation(DELIVERED, hash, sigs)</p>
<p>    Chain->>Chain: Validate signatures</p>
<p>    Chain->>Chain: Anchor hash</p>
<p>    Chain->>Chain: Update Order status</p>
<p>    Chain-->>Courier: Confirmation</p>
<p>    Chain-->>Buyer: Confirmation</p>
<p>    BazChat->>Courier: "Delivery confirmed!"</p>
    BazChat->>Buyer: "Order received!"</code></pre>
<p>---</p>
<h2 id="6-infrastructure-and-deployment">6. Infrastructure and Deployment</h2>
<h3 id="61-production-deployment-architecture">6.1 Production Deployment Architecture</h3>
<pre><code class="language-">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
<p>â”‚                        FRONTEND                              â”‚</p>
<p>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</p>
<p>â”‚  Vercel (Web)  â”‚  App Store/Play Store (Mobile)             â”‚</p>
<p>â”‚  â€¢ Next.js SSR â”‚  â€¢ React Native bundle                      â”‚</p>
<p>â”‚  â€¢ Edge CDN    â”‚  â€¢ OTA updates (Expo)                       â”‚</p>
<p>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</p>
<p>             â”‚</p>
<p>             â–¼</p>
<p>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</p>
<p>â”‚                        API LAYER                             â”‚</p>
<p>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</p>
<p>â”‚  AWS/GCP - Kubernetes Cluster                                â”‚</p>
<p>â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚</p>
<p>â”‚  â”‚  GraphQL   â”‚  â”‚  SubQuery  â”‚  â”‚  IPFS      â”‚             â”‚</p>
<p>â”‚  â”‚  Gateway   â”‚  â”‚  Indexer   â”‚  â”‚  Gateway   â”‚             â”‚</p>
<p>â”‚  â”‚  (Apollo)  â”‚  â”‚  (Node.js) â”‚  â”‚  (Kubo)    â”‚             â”‚</p>
<p>â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚</p>
<p>â”‚         â”‚              â”‚                â”‚                    â”‚</p>
<p>â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”            â”‚</p>
<p>â”‚  â”‚         PostgreSQL (RDS) + Redis             â”‚            â”‚</p>
<p>â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚</p>
<p>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</p>
<p>             â”‚</p>
<p>             â–¼</p>
<p>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</p>
<p>â”‚                    BLOCKCHAIN NODES                          â”‚</p>
<p>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</p>
<p>â”‚  Validator Nodes (3+ geographically distributed)             â”‚</p>
<p>â”‚  â€¢ AWS us-east-1                                             â”‚</p>
<p>â”‚  â€¢ GCP europe-west1                                          â”‚</p>
<p>â”‚  â€¢ Azure asia-southeast1                                     â”‚</p>
<p>â”‚                                                              â”‚</p>
<p>â”‚  Full Nodes (Archive) - 2+ for historical queries           â”‚</p>
<p>â”‚  RPC Nodes (Load-balanced) - 5+ for public API              â”‚</p>
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
<p>---</p>
<h3 id="62-devops-and-cicd">6.2 DevOps and CI/CD</h3>
<pre><code class="language-yaml"><h1>.github/workflows/deploy-chain.yml</h1>
<p>name: Deploy BazariChain</p>
<p>on:</p>
<p>  push:</p>
<p>    branches: [main]</p>
<p>    paths: ['bazari-chain/**']</p>
<p>jobs:</p>
<p>  build-and-deploy:</p>
<p>    runs-on: ubuntu-latest</p>
<p>    steps:</p>
<p>      - uses: actions/checkout@v3</p>
<p>      - name: Build runtime WASM</p>
<p>        run: |</p>
<p>          cd bazari-chain</p>
<p>          cargo build --release</p>
<p>      - name: Run tests</p>
<p>        run: cargo test --all</p>
<p>      - name: Build Docker image</p>
<p>        run: |</p>
<p>          docker build -t bazari-chain:${{ github.sha }} .</p>
<p>          docker tag bazari-chain:${{ github.sha }} bazari-chain:latest</p>
<p>      - name: Push to registry</p>
<p>        run: |</p>
<p>          docker push ghcr.io/bazari/chain:${{ github.sha }}</p>
<p>      - name: Deploy to testnet</p>
<p>        run: |</p>
<p>          kubectl set image deployment/bazari-validator \</p>
<p>            bazari-chain=ghcr.io/bazari/chain:${{ github.sha }}</p>
<p>      - name: Health check</p>
<p>        run: |</p>
<p>          curl -X POST https://testnet-rpc.bazari.network \</p>
<p>            -H "Content-Type: application/json" \</p>
            -d '{"jsonrpc":"2.0","method":"system_health","params":[],"id":1}'</code></pre>
<p>---</p>
<h2 id="7-security-and-auditing">7. Security and Auditing</h2>
<h3 id="71-attack-vectors-and-mitigations">7.1 Attack Vectors and Mitigations</h3>
<p>| Vector | Risk | Mitigation |</p>
<p>|-------|-------|-----------|</p>
<p>| <strong>Reentrancy</strong> | High | Checks-Effects-Interactions pattern; Status flags |</p>
<p>| <strong>Overflow/Underflow</strong> | Medium | Rust safe math (saturating ops); Extensive tests |</p>
<p>| <strong>Forged signatures</strong> | High | Cryptographic verification (sr25519/ed25519); Nonces |</p>
<p>| <strong>Replay attacks</strong> | Medium | Unique nonces; Timestamps; Order IDs |</p>
<p>| <strong>Front-running</strong> | Medium | Commit-reveal for disputes; Timelock before execution |</p>
<p>| <strong>Sybil (spam accounts)</strong> | High | Minimum stake; Reputation; Rate limiting |</p>
<p>| <strong>51% attack</strong> | Low | Multiple validators; High slashing; Cost > gain |</p>
<p>| <strong>DDoS RPC</strong> | Medium | Rate limiting; Load balancer; Cloudflare |</p>
<p>---</p>
<h3 id="72-audit-checklist">7.2 Audit Checklist</h3>
<p><strong>Before Mainnet</strong>:</p>
<ul><li>[ ] Formal smart contract audit (Trail of Bits / OpenZeppelin)</li>
<li>[ ] Pallet fuzzing (cargo-fuzz)</li>
<li>[ ] Load testing (1000+ tps simulated)</li>
<li>[ ] Penetration testing (white-hat hackers)</li>
<li>[ ] Code review by Substrate experts</li>
<li>[ ] Bug bounty program (HackerOne)</li>
<li>[ ] Public testnet for 6+ months</li>
<li>[ ] Cryptography review (signatures, hashes)</li>
<li>[ ] Token economics analysis (simulations)</li>
<li>[ ] Tested disaster recovery plan</li>
<p>---</p>
<h2 id="conclusion">Conclusion</h2>
<p>The Bazari architecture is <strong>modular, scalable, and secure by design</strong>. Each layer has clear responsibilities, and communication between them is standardized.</p>
<p><strong>Next step</strong>: Understand the 3-phase implementation roadmap and future evolutions (ZK-PoD, BLS, AI).</p>
<p>---</p>
<h2 id="next-document">Next Document</h2>
<li><strong><a href="./06-roadmap.html">06-roadmap.html</a></strong>: Complete 3-phase roadmap and long-term vision</li></ul>
<p>---</p>
<p><strong>Bazari</strong> â€” Solid technical architecture for the future of decentralized commerce.</p>

      <!-- Navigation -->
      <div class="doc-navigation">
        <a href="04-ecosystem-modules.html" class="prev">â† Previous</a>
        <a href="06-roadmap.html" class="next">Next â†’</a>
      </div>
    </main>
  </div>

  <script src="../assets/script.v2.js"></script>
</body>
</html>