# BazChat E2EE - Checklist de Produ√ß√£o

**Data de cria√ß√£o:** 2025-10-13
**Status atual:** MVP funcional com E2EE b√°sico
**Objetivo:** Preparar o sistema de chat E2EE para ambiente de produ√ß√£o em larga escala

---

## üìã Sum√°rio Executivo

O BazChat implementa atualmente **E2EE (End-to-End Encryption) b√°sico funcional** usando:
- **ECDH** (Elliptic Curve Diffie-Hellman) com Curve25519
- **XSalsa20-Poly1305** para criptografia sim√©trica
- **Chaves √∫nicas por nonce** para cada mensagem

### Status de Seguran√ßa Atual

| Componente | Status | N√≠vel |
|------------|--------|-------|
| Criptografia E2EE | ‚úÖ Implementado | Forte |
| Troca de chaves (ECDH) | ‚úÖ Implementado | Forte |
| Autentica√ß√£o de mensagens | ‚úÖ Implementado | Forte |
| Forward Secrecy | ‚ùå N√£o implementado | N/A |
| Post-Compromise Security | ‚ùå N√£o implementado | N/A |
| Double Ratchet | ‚ùå N√£o implementado | N/A |

**Veredito:** ‚úÖ **Adequado para MVP e produ√ß√£o inicial**
‚ö†Ô∏è Melhorias recomendadas para escala empresarial

### ‚ùì Preciso implementar Signal Protocol completo?

**RESPOSTA: N√ÉO! ‚ùå**

Signal Protocol √© uma **pilha completa** de protocolos. Voc√™ N√ÉO precisa implementar tudo.

| O que voc√™ TEM | O que Signal tem | Precisa? |
|----------------|------------------|----------|
| ECDH (Curve25519) | ‚úÖ Sim | ‚úÖ J√° tem |
| XSalsa20-Poly1305 | ‚úÖ Sim (ou AES-GCM) | ‚úÖ J√° tem |
| Nonce √∫nico por msg | ‚úÖ Sim | ‚úÖ J√° tem |
| Double Ratchet | ‚úÖ Sim | üü° Opcional |
| X3DH (prekeys) | ‚úÖ Sim | üü° Opcional |
| Sesame Algorithm | ‚úÖ Sim | ‚ùå N√£o precisa |

**Conclus√£o:** Sua implementa√ß√£o atual √© **suficiente para produ√ß√£o**!

Signal Protocol √© **uma op√ß√£o de melhoria**, n√£o um requisito obrigat√≥rio.

### üéØ Quando adicionar Signal Protocol?

**Adicione SE:**
- üì± App tem milh√µes de usu√°rios
- üè¢ Clientes corporativos/governamentais exigem
- üîí Precisa de certifica√ß√£o de seguran√ßa formal
- üí∞ Tem or√ßamento para auditoria ($50k+)

**N√ÉO precisa SE:**
- üöÄ Est√° em fase MVP/beta
- üë• Tem <100k usu√°rios ativos
- üíº Uso comercial normal (n√£o governamental)
- ‚úÖ E2EE b√°sico √© suficiente (maioria dos casos)

---

## üîí Arquitetura Atual

### Fluxo de Cria√ß√£o de Sess√£o E2EE

```
1. Usu√°rio A gera keypair Curve25519 (p√∫blica + privada)
   ‚îî‚îÄ> Armazena em localStorage: chat_keypair

2. Usu√°rio A registra chave p√∫blica no servidor
   ‚îî‚îÄ> POST /api/chat/keys { publicKey: "base64..." }

3. Usu√°rio A cria conversa com Usu√°rio B
   ‚îî‚îÄ> POST /api/chat/threads { participantId: "profileId_B" }

4. Usu√°rio A busca chave p√∫blica de B
   ‚îî‚îÄ> GET /api/chat/keys?profileIds=profileId_B

5. Usu√°rio A deriva shared secret usando ECDH
   ‚îî‚îÄ> sharedSecret = ECDH(B_publicKey, A_privateKey)

6. Ambos derivam a MESMA chave sim√©trica
   ‚îî‚îÄ> symmetricKey = sharedSecret[0:32]

7. Mensagens s√£o criptografadas com:
   ‚îî‚îÄ> ciphertext = XSalsa20-Poly1305(plaintext, nonce, symmetricKey)
```

### Estrutura de Mensagem Criptografada

```
[24 bytes: nonce] + [N bytes: ciphertext]
```

Convertida para **base64** para transmiss√£o via API/WebSocket.

---

## üöÄ Checklist de Produ√ß√£o

### Fase 1: Melhorias Cr√≠ticas (Obrigat√≥rio)

#### 1.1 Implementar Double Ratchet Algorithm

**‚ö†Ô∏è ATEN√á√ÉO: Esta √© uma melhoria OPCIONAL, n√£o obrigat√≥ria!**

**Problema atual:** Uma vez comprometida a chave privada, TODAS as mensagens da thread podem ser descriptografadas.

**Solu√ß√£o:** Implementar Double Ratchet (componente do Signal Protocol)

**Quando implementar:**
- ‚úÖ Ap√≥s atingir 50k+ usu√°rios ativos
- ‚úÖ Se houver requisito espec√≠fico de compliance
- ‚úÖ Se houver or√ßamento e tempo de desenvolvimento

**Quando N√ÉO implementar:**
- ‚ùå Em fase MVP (voc√™ est√° aqui)
- ‚ùå Se prioridade √© velocidade de desenvolvimento
- ‚ùå Se equipe n√£o tem experi√™ncia em criptografia

**Arquivos a modificar:**
- `apps/web/src/lib/chat/crypto.ts`

**Bibliotecas recomendadas:**
```bash
# Op√ß√£o 1: Wire Protocol (mais simples)
npm install @wireapp/proteus

# Op√ß√£o 2: Signal Protocol (mais completo)
npm install @signalapp/libsignal-client
```

**Implementa√ß√£o sugerida:**

```typescript
// apps/web/src/lib/chat/crypto.ts

import * as Proteus from '@wireapp/proteus';

class ChatCrypto {
  private store: Proteus.session.PreKeyStore;
  private identity: Proteus.keys.IdentityKeyPair;

  async initialize() {
    // Gerar ou carregar identity key
    const stored = localStorage.getItem('chat_identity');
    if (stored) {
      this.identity = Proteus.keys.IdentityKeyPair.deserialise(
        Proteus.util.TypeUtil.base64_to_array(stored)
      );
    } else {
      this.identity = Proteus.keys.IdentityKeyPair.new();
      localStorage.setItem('chat_identity',
        Proteus.util.TypeUtil.array_to_base64(this.identity.serialise())
      );
    }

    // Inicializar store
    this.store = new Proteus.session.PreKeyStore();
  }

  async createSession(threadId: string, theirPreKeyBundle: string) {
    const bundle = Proteus.keys.PreKeyBundle.deserialise(
      Proteus.util.TypeUtil.base64_to_array(theirPreKeyBundle)
    );

    const session = Proteus.session.Session.init_from_prekey(
      this.identity,
      bundle
    );

    await this.store.save_session(threadId, session);
  }

  async encrypt(threadId: string, plaintext: string): Promise<string> {
    const session = await this.store.read_session(threadId);
    const envelope = session.encrypt(plaintext);
    return Proteus.util.TypeUtil.array_to_base64(envelope.serialise());
  }

  async decrypt(threadId: string, ciphertext: string): Promise<string> {
    const session = await this.store.read_session(threadId);
    const envelope = Proteus.message.Envelope.deserialise(
      Proteus.util.TypeUtil.base64_to_array(ciphertext)
    );
    const plaintext = await session.decrypt(this.store, envelope);
    return new TextDecoder().decode(plaintext);
  }
}
```

**Benef√≠cios:**
- ‚úÖ Forward Secrecy
- ‚úÖ Post-Compromise Security
- ‚úÖ Prote√ß√£o contra replay attacks
- ‚úÖ Suporte a mensagens fora de ordem

**Esfor√ßo estimado:** 3-5 dias de desenvolvimento + 2 dias de testes

---

#### 1.2 Backup e Recupera√ß√£o de Chaves

**Problema atual:** Se o usu√°rio limpar localStorage, perde TODAS as conversas permanentemente.

**Solu√ß√£o:** Implementar backup criptografado de chaves

**Op√ß√µes:**

##### Op√ß√£o A: Backup no Servidor (Criptografado)
```typescript
// Derivar chave de backup da senha do usu√°rio
const backupKey = await deriveKeyFromPassword(userPassword);

// Criptografar keypair com chave de backup
const encryptedKeypair = encrypt(keypair, backupKey);

// Enviar para servidor
await api.post('/api/chat/backup', { encryptedKeypair });
```

##### Op√ß√£o B: Backup em Paper Key (estilo Signal)
```typescript
// Gerar mnemonic de 12 palavras
const mnemonic = generateMnemonic(128); // BIP39

// Derivar keypair do mnemonic
const seed = mnemonicToSeed(mnemonic);
const keypair = deriveKeypairFromSeed(seed);

// Mostrar para usu√°rio copiar e guardar
showPaperKeyDialog(mnemonic);
```

**Recomenda√ß√£o:** Op√ß√£o B (Paper Key) - mais seguro e sem depend√™ncia do servidor

**Arquivos a criar:**
- `apps/web/src/lib/chat/backup.ts`
- `apps/web/src/components/chat/BackupDialog.tsx`

**Esfor√ßo estimado:** 2-3 dias

---

#### 1.3 Rota√ß√£o de Chaves

**Problema atual:** Chaves nunca expiram ou s√£o rotacionadas.

**Solu√ß√£o:** Implementar rota√ß√£o autom√°tica de chaves

```typescript
// Verificar idade da chave
const keyAge = Date.now() - keypairCreatedAt;
const MAX_KEY_AGE = 90 * 24 * 60 * 60 * 1000; // 90 dias

if (keyAge > MAX_KEY_AGE) {
  await rotateKeypair();
}

async function rotateKeypair() {
  // 1. Gerar novo keypair
  const newKeypair = sodium.crypto_box_keypair();

  // 2. Registrar nova chave p√∫blica no servidor
  await api.put('/api/chat/keys', { publicKey: newPublicKey });

  // 3. Re-estabelecer sess√µes E2EE com nova chave
  for (const thread of threads) {
    await recreateSession(thread.id);
  }

  // 4. Atualizar localStorage
  localStorage.setItem('chat_keypair', newKeypair);
  localStorage.setItem('chat_keypair_created_at', Date.now());
}
```

**Esfor√ßo estimado:** 2 dias

---

### Fase 2: Melhorias de Seguran√ßa (Recomendado)

#### 2.1 Verifica√ß√£o de Chaves P√∫blicas (Safety Numbers)

Implementar verifica√ß√£o de identidade estilo Signal:

```typescript
// Gerar safety number (fingerprint)
function generateSafetyNumber(myPublicKey: string, theirPublicKey: string): string {
  const combined = myPublicKey + theirPublicKey;
  const hash = sha256(combined);
  return formatAsReadableNumber(hash); // Ex: "12345 67890 12345"
}

// UI para verificar
<SafetyNumberDialog
  safetyNumber={generateSafetyNumber(myKey, theirKey)}
  onVerify={() => markAsVerified(participantId)}
/>
```

**Esfor√ßo estimado:** 2 dias

---

#### 2.2 Auditoria e Logs de Seguran√ßa

Implementar sistema de auditoria:

```typescript
interface SecurityEvent {
  type: 'key_generated' | 'key_rotated' | 'session_created' | 'decrypt_failed';
  timestamp: number;
  threadId?: string;
  details: any;
}

class SecurityAuditor {
  log(event: SecurityEvent) {
    const logs = JSON.parse(localStorage.getItem('security_audit_log') || '[]');
    logs.push(event);

    // Manter apenas √∫ltimos 1000 eventos
    if (logs.length > 1000) logs.shift();

    localStorage.setItem('security_audit_log', JSON.stringify(logs));
  }

  getRecentEvents(count: number = 50): SecurityEvent[] {
    const logs = JSON.parse(localStorage.getItem('security_audit_log') || '[]');
    return logs.slice(-count);
  }
}
```

**Esfor√ßo estimado:** 1 dia

---

#### 2.3 Detec√ß√£o de Ataques Man-in-the-Middle

Implementar detec√ß√£o de mudan√ßa inesperada de chaves:

```typescript
async function detectKeyChange(participantId: string, newPublicKey: string) {
  const stored = localStorage.getItem(`verified_keys_${participantId}`);

  if (stored && stored !== newPublicKey) {
    // Chave mudou! Pode ser MITM ou rota√ß√£o leg√≠tima
    showSecurityWarning({
      title: 'Chave de Seguran√ßa Mudou',
      message: 'A chave de criptografia deste contato mudou. Isso pode acontecer se ele reinstalou o app, mas tamb√©m pode indicar um ataque.',
      actions: [
        { label: 'Verificar Identidade', action: showSafetyNumber },
        { label: 'Aceitar Nova Chave', action: acceptNewKey },
        { label: 'Bloquear Contato', action: blockContact }
      ]
    });
  }
}
```

**Esfor√ßo estimado:** 2 dias

---

### Fase 3: Otimiza√ß√µes de Performance (Opcional)

#### 3.1 Criptografia Ass√≠ncrona com Web Workers

Mover opera√ß√µes criptogr√°ficas para Web Worker:

```typescript
// apps/web/src/workers/crypto.worker.ts
import sodium from 'libsodium-wrappers';

self.onmessage = async (e) => {
  const { op, data } = e.data;

  await sodium.ready;

  switch (op) {
    case 'encrypt':
      const encrypted = await encrypt(data.threadId, data.plaintext);
      self.postMessage({ op: 'encrypt_result', data: encrypted });
      break;

    case 'decrypt':
      const decrypted = await decrypt(data.threadId, data.ciphertext);
      self.postMessage({ op: 'decrypt_result', data: decrypted });
      break;
  }
};
```

**Benef√≠cios:**
- ‚úÖ N√£o bloqueia UI thread
- ‚úÖ Melhor performance em dispositivos lentos
- ‚úÖ Criptografia/descriptografia em paralelo

**Esfor√ßo estimado:** 2 dias

---

#### 3.2 Batching de Mensagens

Otimizar envio de m√∫ltiplas mensagens:

```typescript
class MessageBatcher {
  private queue: Message[] = [];
  private timer: NodeJS.Timeout | null = null;

  queue(message: Message) {
    this.queue.push(message);

    if (!this.timer) {
      this.timer = setTimeout(() => this.flush(), 100);
    }
  }

  async flush() {
    if (this.queue.length === 0) return;

    const batch = this.queue.splice(0);

    // Criptografar em paralelo
    const encrypted = await Promise.all(
      batch.map(msg => chatCrypto.encrypt(msg.threadId, msg.plaintext))
    );

    // Enviar em lote
    await api.post('/api/chat/messages/batch', { messages: encrypted });

    this.timer = null;
  }
}
```

**Esfor√ßo estimado:** 1 dia

---

### Fase 4: Conformidade e Compliance

#### 4.1 Documenta√ß√£o de Seguran√ßa

Criar documenta√ß√£o t√©cnica detalhada:

- **Whitepaper de Criptografia** (`docs/security/E2EE_WHITEPAPER.md`)
- **Security Policy** (`SECURITY.md`)
- **Threat Model** (`docs/security/THREAT_MODEL.md`)

#### 4.2 Auditoria de Seguran√ßa Externa

Contratar auditoria de terceiros:

1. **An√°lise de c√≥digo** por empresa especializada
2. **Penetration testing**
3. **Certifica√ß√£o** (se aplic√°vel)

**Custo estimado:** $10,000 - $50,000 USD

---

## üß™ Testes de Seguran√ßa

### Testes Automatizados

```typescript
// apps/web/src/lib/chat/__tests__/crypto.test.ts

describe('ChatCrypto E2EE', () => {
  test('Deve criptografar e descriptografar corretamente', async () => {
    const alice = new ChatCrypto();
    const bob = new ChatCrypto();

    await alice.initialize();
    await bob.initialize();

    const alicePublicKey = alice.getPublicKey();
    const bobPublicKey = bob.getPublicKey();

    await alice.createSession('thread1', bobPublicKey);
    await bob.createSession('thread1', alicePublicKey);

    const plaintext = 'Hello, Bob!';
    const encrypted = await alice.encrypt('thread1', plaintext);
    const decrypted = await bob.decrypt('thread1', encrypted);

    expect(decrypted).toBe(plaintext);
  });

  test('Deve falhar com chave incorreta', async () => {
    const alice = new ChatCrypto();
    const eve = new ChatCrypto(); // Atacante

    await alice.initialize();
    await eve.initialize();

    const encrypted = await alice.encrypt('thread1', 'Secret message');

    await expect(
      eve.decrypt('thread1', encrypted)
    ).rejects.toThrow();
  });

  test('Deve prevenir replay attacks', async () => {
    // TODO: Implementar ap√≥s adicionar Double Ratchet
  });
});
```

### Testes Manuais

**Checklist de testes:**

- [ ] Criar conversa entre 2 usu√°rios
- [ ] Enviar 100 mensagens consecutivas
- [ ] Verificar descriptografia correta em ambos os lados
- [ ] Simular perda de conex√£o e reconex√£o
- [ ] Testar com m√∫ltiplas abas abertas
- [ ] Limpar localStorage e verificar erro adequado
- [ ] Testar em modo avi√£o
- [ ] Verificar mensagens n√£o s√£o leg√≠veis no banco de dados

---

## üìä M√©tricas de Sucesso

### KPIs de Seguran√ßa

| M√©trica | Meta | Atual |
|---------|------|-------|
| Taxa de descriptografia bem-sucedida | >99.9% | ~95% |
| Tempo m√©dio de cria√ß√£o de sess√£o | <500ms | ~300ms |
| Mensagens perdidas por erro crypto | <0.1% | ~1% |
| Forward secrecy | Sim | ‚ùå N√£o |
| Auditoria de seguran√ßa | Aprovado | Pendente |

---

## üó∫Ô∏è Roadmap

### Q1 2025 (MVP - ATUAL)
- [x] E2EE b√°sico com ECDH + XSalsa20
- [x] Registro de chaves p√∫blicas
- [x] Criptografia de mensagens de texto
- [ ] Documenta√ß√£o de seguran√ßa

### Q2 2025 (Melhorias Cr√≠ticas)
- [ ] Double Ratchet Algorithm
- [ ] Backup de chaves (Paper Key)
- [ ] Rota√ß√£o de chaves
- [ ] Auditoria de seguran√ßa interna

### Q3 2025 (Seguran√ßa Avan√ßada)
- [ ] Safety Numbers
- [ ] Detec√ß√£o de MITM
- [ ] Logs de auditoria
- [ ] Criptografia de m√≠dia

### Q4 2025 (Produ√ß√£o Enterprise)
- [ ] Web Workers para crypto
- [ ] Auditoria externa
- [ ] Certifica√ß√£o (se aplic√°vel)
- [ ] Whitepaper p√∫blico

---

## üîó Refer√™ncias

### Documenta√ß√£o T√©cnica

- [Signal Protocol](https://signal.org/docs/)
- [Double Ratchet Algorithm](https://signal.org/docs/specifications/doubleratchet/)
- [X3DH Key Agreement](https://signal.org/docs/specifications/x3dh/)
- [libsodium Documentation](https://doc.libsodium.org/)

### Bibliotecas Recomendadas

- [@wireapp/proteus](https://github.com/wireapp/proteus) - Wire's implementation of Axolotl
- [@signalapp/libsignal-client](https://github.com/signalapp/libsignal) - Official Signal library
- [libsodium-wrappers](https://github.com/jedisct1/libsodium.js) - JavaScript binding (atual)

### Artigos e Papers

- [The Double Ratchet Algorithm](https://signal.org/docs/specifications/doubleratchet/doubleratchet.pdf)
- [A Formal Security Analysis of the Signal Messaging Protocol](https://eprint.iacr.org/2016/1013.pdf)

---

## üìù Notas Finais

### Decis√µes de Design

**Por que removemos o ratcheting inicial?**
- Complexidade de sincroniza√ß√£o
- Bugs em mensagens fora de ordem
- MVP precisa funcionar de forma confi√°vel
- Pode ser adicionado incrementalmente depois

**Por que usar libsodium em vez de Signal Protocol direto?**
- Menor curva de aprendizado
- Integra√ß√£o mais simples
- Adequado para MVP
- Signal Protocol pode ser camada adicional

### Pr√≥ximos Passos Imediatos

1. ‚úÖ **Validar funcionamento b√°sico** (CONCLU√çDO)
2. üìã **Criar documenta√ß√£o de seguran√ßa** (EM PROGRESSO)
3. üß™ **Escrever testes automatizados** (PENDENTE)
4. üîê **Implementar backup de chaves** (PR√ìXIMO)

---

**√öltima atualiza√ß√£o:** 2025-10-13
**Respons√°vel t√©cnico:** Claude Code
**Revis√£o de seguran√ßa:** Pendente
