# bazari-dispute Pallet - Implementation Prompt

**Phase**: P2 - Proof of Commerce (Week 16-19)
**Effort**: 3-4 semanas
**Dependencies**: bazari-attestation, bazari-escrow, pallet-randomness (VRF)

---

## ðŸ“‹ Contexto

**Problema**: Disputas resolvidas centralmente sem transparÃªncia

**SoluÃ§Ã£o**: Dispute resolution descentralizado com VRF juror selection + commit-reveal voting

**Impacto**: Disputas justas, transparentes, resistentes a collusÃ£o

---

## ðŸŽ¯ Objetivo

Implementar `bazari-dispute` com:
1. Storage: Disputes, JurorVotes, DisputeHistory
2. Extrinsics: open_dispute, select_jurors (VRF), commit_vote, reveal_vote, execute_ruling
3. VRF: Randomness trait para juror selection
4. Commit-Reveal: 2-phase voting (commit 24h, reveal 24h)

**Output**:
- âœ… `/root/bazari-chain/pallets/bazari-dispute/src/lib.rs`
- âœ… VRF juror selection (5 jurors random)
- âœ… Commit-reveal voting system
- âœ… Ruling execution (RefundBuyer/ReleaseSeller/Partial)

---

## âœ… Checklist

### Step 1-2: Estrutura + Storage
```rust
pub struct Dispute<T: Config> {
    pub dispute_id: u64,
    pub order_id: u64,
    pub plaintiff: T::AccountId,
    pub defendant: T::AccountId,
    pub jurors: BoundedVec<T::AccountId, ConstU32<5>>,
    pub evidence_cid: BoundedVec<u8, ConstU32<64>>,
    pub status: DisputeStatus,
    pub ruling: Option<Ruling>,
    pub created_at: BlockNumberFor<T>,
    pub commit_deadline: BlockNumberFor<T>,
    pub reveal_deadline: BlockNumberFor<T>,
}

pub enum DisputeStatus {
    Open,
    JurorsSelected,
    CommitPhase,
    RevealPhase,
    Resolved,
}

pub enum Ruling {
    RefundBuyer,
    ReleaseSeller,
    PartialRefund(u8), // 0-100%
}
```

### Step 3: Extrinsics

1. **open_dispute**: Create dispute + select 5 jurors via VRF
2. **commit_vote**: Submit hash(vote + salt)
3. **reveal_vote**: Submit vote + salt (validates hash)
4. **execute_ruling**: Tally votes (3-of-5 quorum) + execute

### Step 4-5: VRF Integration

```rust
impl<T: Config> Pallet<T> {
    pub fn select_jurors_vrf(dispute_id: u64) -> Result<Vec<T::AccountId>, DispatchError> {
        let randomness = T::Randomness::random(&dispute_id.encode());
        // Select 5 eligible jurors (reputation > 500)
        let eligible = // query jurors from fulfillment pallet
        // Use VRF output to shuffle + select 5
    }
}
```

### Step 6-10: Tests, Runtime, Config

---

## ðŸš« Anti-Patterns

âŒ **NÃ£o usar randomness simples**: Usar VRF (pallet-randomness)
âŒ **NÃ£o permitir vote sem commit**: Validar commit existe antes de reveal
âŒ **NÃ£o permitir reveal antes de deadline**: Validar timing
âŒ **NÃ£o executar ruling sem quorum**: Validar >= 3 votes

---

## ðŸ“¦ DependÃªncias

- pallet-bazari-attestation (proofs)
- pallet-bazari-escrow (ruling execution)
- pallet-bazari-fulfillment (juror registry)
- pallet-randomness (VRF)

---

## ðŸ¤– Prompt para Claude Code

```
Implementar bazari-dispute: dispute resolution com VRF jurors + commit-reveal voting.

OBJETIVO:
- Storage: Dispute struct (order_id, plaintiff, defendant, jurors, votes, ruling)
- Extrinsics: open_dispute, commit_vote, reveal_vote, execute_ruling
- VRF: Select 5 random jurors (reputation > 500)
- Commit-Reveal: 2-phase voting (24h each)
- Ruling: 3-of-5 quorum â†’ RefundBuyer/ReleaseSeller/Partial

CHECKLIST:
âœ… Criar /root/bazari-chain/pallets/bazari-dispute/
âœ… Implementar Dispute struct (status, jurors, votes, ruling)
âœ… Implementar open_dispute (VRF juror selection)
âœ… Implementar commit_vote (hash(vote + salt))
âœ… Implementar reveal_vote (validate hash, store vote)
âœ… Implementar execute_ruling (tally 3-of-5, call escrow)
âœ… Usar pallet-randomness para VRF
âœ… Validar deadlines (commit 24h, reveal 24h)
âœ… Integrar no runtime (pallet_index = 28)

ANTI-PATTERNS:
âŒ NÃƒO usar randomness simples (usar VRF)
âŒ NÃƒO permitir reveal sem commit
âŒ NÃƒO permitir reveal antes de deadline
âŒ NÃƒO executar ruling sem >= 3 votes
```

---

**Generated by**: Claude Code | **Version**: 1.0.0
